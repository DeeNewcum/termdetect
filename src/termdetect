#!/usr/bin/perl

# auto-detect which terminal emulator we're talking to
#
# https://github.com/DeeNewcum/termdetect


# Copyright (C) 2012  Dee Newcum
# https://github.com/DeeNewcum/
#       You may redistribute this program and/or modify it under the terms of the GNU General Public
#       License as published by the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.


    use strict;
    use warnings;

    use FindBin;
    use lib $FindBin::Bin;
    use Terminfo_Parser;
    use Termdetect_Tests;
    use Termdetect_Match;

    use Getopt::Long;
    use Data::Dumper;


our %ARGV;
process_cmdline();


## read in the termmatch database
my $termmatch_db = parse_terminfo(scalar(slurp("$FindBin::Bin/termmatch.src")));
    #print ti_dump_terminal(values %$termmatch_db);      exit;


## read in the test results from the current terminal
my $test_results = perform_all_tests();
    #print Dumper $test_results;     exit;
    #print ansi_escape_no_nl(Dumper $test_results);      exit;

## ... and match them together
my $term = match_results($test_results, $termmatch_db,
    !($ARGV{snapshot} || $ARGV{dump} || $ARGV{check}));



## generate the desired output
if ($ARGV{snapshot}) {
    show_snapshot($test_results);

} elsif ($ARGV{dump}) {
    # Does this overlap with --snapshot too much?  If so, then we'll get rid of this.
    foreach my $cap (sort keys %$test_results) {
        printf "%25s  %s\n", $cap, summarize_result($test_results->{$cap});
    }

} elsif ($ARGV{result}) {
    if (exists $test_results->{$ARGV{result}}) {
        print summarize_result($test_results->{$ARGV{result}}), "\n";
    }

} elsif (!$ARGV{check}) {
    if (defined($term)) {
        if ($ARGV{t}) {
            print "$term\n";
        } else {
            my @fields = (
                    ['terminal',            $term],
                    ['version',             $test_results->{s_term_version}],
                    ['encoding',            $test_results->{s_encoding}],
                    ['terminal size',       $test_results->{s_window_size}],
                    ['font size',           $test_results->{s_font_size}],
                    ['window position',     $test_results->{s_window_pos}],
                    ['screen size',         $test_results->{s_screen_size}],
            );
            foreach my $field (@fields) {
                next unless defined($field->[1]);
                my $disp = $field->[1];
                if (ref($disp) eq 'HASH' && exists $disp->{received}) {
                    $disp = $disp->{received};
                }
                printf "%20s:   %s\n", $field->[0], $disp;
            }
        }
    } else {
        print STDERR "No \$TERM matched.  Run again with --check for more information.\n";
        print "$ENV{TERM}\n"        if ($ARGV{t});      # pass through the existing terminal
    }
}




sub process_cmdline {
    GetOptions( \%ARGV,
                    map {"$_:s"}        # all options have optional arguments, like Getopt::Casual
        "help|h|?",
        qw( check nose t snapshot result dump ),
    ) or usage();
    %ARGV = map {length()?$_:1} %ARGV;      # arguments are optional
    $ARGV{help} and usage();
}


sub usage {
    print STDERR <DATA>;
    exit;
}


sub show_snapshot {
    my ($test_results) = @_;

    # Patterns that may potentionally match the current results.
    # If one of these patterns matches, then that's really good, because it increases the 
    # chances that we'll match other results.
    #
    # Left-most are tried first, right-most tried last.
    my %generalizations = (
        r_ext_cursor_pos    => ["\e[%+R"],
        r_window_pos        => ["\e[3;%+t"],
        r_window_size_px    => ["\e[4;%+t"],
        r_window_size_char  => ["\e[8;%+t"],
        r_screen_size       => ["\e[9;%+t"],
        r_window_title      => ["\e]l%*\e\\"],
        r_window_icon_label => ["\e]L%*\e\\"],
    );
    foreach my $list (values %generalizations) {
        unshift @$list, '';         # highest priority:  match an empty string
        push    @$list, '%+';       # lowest priority:  match a non-empty string
    }
    foreach my $cap (sort keys %$test_results) {
        next if $Termdetect_Tests::rarely_tested_synthetics{$cap};
        my $r = summarize_result($test_results->{$cap});
        foreach my $gen (@{ $generalizations{$cap} }) {
            if (Termdetect_Match::match_one_field($test_results->{$cap}, {assign => $gen})) {
                ($r) = ansi_escape($gen);
                last;
            }
        }
        if ($cap eq 'r_device_attr2' && $test_results->{$cap}{received} =~ /^\e(\[>[^;]*;)[^;]*(;.*c)$/) {
            $r = "\\E$1\%+$2";
        }
        printf "    %s=%s,\n", $cap, $r;
    }
}


# quickly read a whole file         see also: File::Slurp and IO::All->slurp()
sub slurp {my$p=open(my$f,"$_[0]")or die$!;my@o=<$f>;close$f;waitpid($p,0);wantarray?@o:join("",@o)}




__END__
termdetect

    -t      only display the matched $TERM

    --check=<term>
            Used to debug termmatch.src.  Displays extra information about how the current terminal
            matches up to the specified entry in termmatch.src.

    --check
            Displays extra information about EVERY entry in termmatch.src.

    --nose
            "No Side Effects".  Doesn't run tests that may have side-effects.
            Gibberish may still be displayed on your screen, but they will be (mostly) erased
            before exiting.  Most tests don't have side-effects, so using this option doesn't
            greatly reduce the chances of correctly identifying your terminal.

    --snapshot
            Outputs the current tests results in a form that's suitable for pasting into
            termmatch.src.

    --dump
            Dumps the result of all tests run.
            Similar to --snapshot, but gives a little more detailed information.

    --result=<test_id>
            Display the result of a single test.  To get a list of test_ids you can use, run
            termdetect --dump
