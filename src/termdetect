#!/usr/bin/perl

# auto-detect which terminal emulator we're talking to
#
# https://github.com/DeeNewcum/termdetect


# Copyright (C) 2012  Dee Newcum
# https://github.com/DeeNewcum/
#       You may redistribute this program and/or modify it under the terms of the GNU General Public
#       License as published by the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.


    use strict;
    use warnings;

    # improved FindBin
    use Cwd 'abs_path';
    use File::Basename;
    use lib $FindBin::Bin = dirname( abs_path $0 );

    use Terminfo_Parser;
    use Termdetect_Tests;
    use Termdetect_Match;

    use Getopt::Long;
    use Data::Dumper;

    
    # constants
    use constant VERSION => "0.10";


our %ARGV;
process_cmdline();

# we can't detect the terminal type if there's no terminal connected in the first place
if (!-t STDERR || !-t STDIN) {       # isatty(3)
    die "Not connected to a terminal.\n";
}

my $termmatch_file = locate_termmatch_file();

## read in the termmatch database
my $termmatch_db = parse_terminfo(scalar(slurp($termmatch_file)));
    #print ti_dump_terminal(values %$termmatch_db);      exit;

## read in the test results from the current terminal
my $test_results = perform_all_tests();
    #print Dumper $test_results;     exit;
    #print ansi_escape_no_nl(Dumper $test_results);      exit;

## ... and match them together
my $term = match_results($test_results, $termmatch_db,
    !($ARGV{snapshot} || $ARGV{dump} || $ARGV{check}));



## generate the desired output
if ($ARGV{snapshot}) {
    show_snapshot($test_results);

} elsif ($ARGV{dump}) {
    # Does this overlap with --snapshot too much?  If so, then we'll get rid of this.
    foreach my $cap (sort keys %$test_results) {
        printf "%25s  %s\n", $cap, summarize_result($test_results->{$cap});
    }

} elsif ($ARGV{result}) {
    if (exists $test_results->{$ARGV{result}}) {
        print summarize_result($test_results->{$ARGV{result}}), "\n";
    }

} elsif (!$ARGV{check}) {
    if (defined($term)) {
        if ($ARGV{t}) {
            my $final_term = TERM_fallback($term, $termmatch_db);
            if ($final_term) {
                print "$final_term\n";
            } else {
               print STDERR "The suggested \$TERM \"$term\" wasn't found.\n";
                print STDERR "        \n";
                help_install_terminfos();
            }
        } else {
            my $all_aliases = join " / ", @{ $termmatch_db->{$term}{termnames}};
            my @fields = (
                    ['terminal',            $all_aliases],
                    ['version',             $test_results->{s_term_version}],
                    ['encoding',            $test_results->{s_encoding}],
                    ['terminal size',       $test_results->{s_window_size}],
                    ['font size',           $test_results->{s_font_size}],
                    ['window position',     $test_results->{s_window_pos}],
                    ['screen size',         $test_results->{s_screen_size}],
            );
            foreach my $field (@fields) {
                next unless defined($field->[1]);
                my $disp = $field->[1];
                if (ref($disp) eq 'HASH' && exists $disp->{received}) {
                    $disp = $disp->{received};
                }
                printf "%20s:   %s\n", $field->[0], $disp;
            }

            if (!does_terminfo_exist("vt100-putty")) {
                print "\nThe full set of terminfo entries haven't been installed,\n",
                        "see --help-terminfo for info on installing them.\n";
            }
        }
    } else {
        print STDERR "No \$TERM matched.  Run again with --check for more information.\n";
        print "$ENV{TERM}\n"        if ($ARGV{t});      # pass through the existing terminal
    }
}




sub process_cmdline {
    GetOptions( \%ARGV,
                    map {"$_:s"}        # all options have optional arguments, like Getopt::Casual
        "help|h|?",
        qw( check nose t snapshot result dump help-submit help-terminfo version ),
    ) or usage();
    %ARGV = map {length()?$_:1} %ARGV;      # arguments are optional
    $ARGV{help} and usage();
    $ARGV{'help-submit'} and help_submit();
    $ARGV{'help-terminfo'} and help_install_terminfos();
    if ($ARGV{version}) {
        print "termdetect, version ", VERSION, "\n";
        exit;
    }
}


sub usage {
    print STDERR <DATA>;
    exit;
}

sub help_submit {
    print STDOUT <<'EOF';

The author doesn't have access to all terminals (or all versions of terminals).
If termdetect doesn't detect your terminal, you can help greatly by submitting
the test results for your particular terminal.

1. Run  termdetect --dump

2. Create a new issue at https://github.com/DeeNewcum/termdetect/issues
   or contact me via any method mentioned at https://github.com/DeeNewcum

3. In the information you send, include:

    - the output of   termdetect --dump

    - the name and version number of your terminal

    - the reason for submitting the data, eg:
            - there was no entry for this terminal
            - there was an entry, but it didn't correctly identify your terminal

EOF
    exit;
}


# look in various places that the termmatch.src file could be, and if not found,
# tell the user where they can go stick it
sub locate_termmatch_file {
    my @possible_locations = (
        "$FindBin::Bin/termmatch.src",      # in the same directory as this script
        "$ENV{HOME}/.termmatch.src",
        "/etc/termmatch.src",
        );
    foreach my $loc (@possible_locations) {
        return $loc if (-e $loc);
    }
    print STDERR <<"EOF";
Error: File 'termmatch.src' not found.

Please copy it from the installation tarball to one of these places:
    - the same directory as this script ($FindBin::Bin)
    - \$HOME/.termmatch.src
    - /etc/termmatch.src
EOF
    exit 1;
}


sub TERM_fallback {
    my ($proposed_term, $termmatch_db) = @_;

    my $termmatch_entry = $termmatch_db->{$proposed_term};
    my @fallback_list = @{$termmatch_entry->{termnames}};
    if ($termmatch_entry->{fields}{fallback}) {
        push @fallback_list,
             split /\|/,
                   $termmatch_entry->{fields}{fallback}{assign};
    }
        #print Dumper \@fallback_list; exit;

    foreach my $fallback (@fallback_list) {
        if (does_terminfo_exist($fallback)) {
            return $fallback;
        }
    }

    return undef;
}


# check the local computer's terminfo information to see if the proposed $TERM
# is found there
sub does_terminfo_exist {
    my ($term) = @_;
    # there are many ways to do this:
    #   - toe -a    (or just `toe` in Solaris)
    #   - infocmp $TERM
    #   - tput -T$TERM longname;  echo $?

    # for now, we just implement the tput one
    my $pid = fork();
    defined($pid)   or die $!;
    if (!$pid) {
        open STDOUT, '>', '/dev/null';
        open STDERR, '>', '/dev/null';
        exec "tput", "-T$term", "longname";
    }
    waitpid($pid, 0);
    my $error_value = ($? >> 8);
    return ($error_value == 0);
}


sub help_install_terminfos {
    die <<'EOF';
Instructions for installing the full set of terminfo entries:

On Debian or Ubuntu:
    sudo apt-get install ncurses-term
                        
Otherwise:
    TMP=$(mktemp);
    curl http://invisible-island.net/datafiles/current/terminfo.src.gz | gzip -dc > $TMP;
    tic $TMP; rm $TMP
            (run that as root if you want, otherwise it will install things
             in ~/.terminfo/ )
EOF
}


sub show_snapshot {
    my ($test_results) = @_;

    # Patterns that may potentionally match the current results.
    # If one of these patterns matches, then that's really good, because it increases the 
    # chances that we'll match other results.
    #
    # Left-most are tried first, right-most tried last.
    my %generalizations = (
        r_ext_cursor_pos    => ["\e[%+R"],
        r_window_pos        => ["\e[3;%+t"],
        r_window_size_px    => ["\e[4;%+t"],
        r_window_size_char  => ["\e[8;%+t"],
        r_screen_size       => ["\e[9;%+t"],
        r_window_title      => ["\e]l%*\e\\"],
        r_window_icon_label => ["\e]L%*\e\\"],
    );
    foreach my $list (values %generalizations) {
        unshift @$list, '';         # highest priority:  match an empty string
        push    @$list, '%+';       # lowest priority:  match a non-empty string
    }
    foreach my $cap (sort keys %$test_results) {
        next if $Termdetect_Tests::rarely_tested_synthetics{$cap};
        my $r = summarize_result($test_results->{$cap});
        foreach my $gen (@{ $generalizations{$cap} }) {
            if (Termdetect_Match::match_one_field($test_results->{$cap}, {assign => $gen})) {
                ($r) = ansi_escape($gen);
                last;
            }
        }
        if ($cap eq 'r_device_attr2' && $test_results->{$cap}{received} =~ /^\e(\[>[^;]*;)[^;]*(;.*c)$/) {
            $r = "\\E$1\%+$2";
        }
        printf "    %s=%s,\n", $cap, $r;
    }
}


# quickly read a whole file         see also: File::Slurp and IO::All->slurp()
sub slurp {my$p=open(my$f,"$_[0]")or die$!;my@o=<$f>;close$f;waitpid($p,0);wantarray?@o:join("",@o)}




__END__
termdetect

  -t    Display only the matched $TERM.  Intended to be used like this:
                export TERM=$(termdetect -t)

  --result=<test_id>
        Display the result of a single test.  To get a list of test_ids you
        can use, run      termdetect --dump

  --nose
        "No Side Effects".  Doesn't run tests that have significant side-effects.
        Most tests don't have side-effects, so using this option doesn't greatly
        reduce the chances of correctly identifying your terminal.
        Note that there are some smaller side-effects that are unavoidable,
        even when --nose is used.  Read more at:
            https://github.com/DeeNewcum/termdetect/blob/master/doc/side-effects.md

  --dump
        Dumps the result of all tests run.
        Similar to --snapshot, but gives a little more detailed information.
        See here for details on what each line means:
            https://github.com/DeeNewcum/termdetect/blob/master/doc/termmatch.md

  --check=<term>
        In the case of a mismatch, this tells you which specific tests gave
        different answers than were expected.  This helps suggest changes that
        may need to be made to the termmatch.src database.
        If no terminal name is given, it displays information about EVERY entry
        in the database.

  --snapshot
        Outputs the current tests results in a form that's suitable for 
        cut-n-pasting into termmatch.src.

  --version
        Show version number.

  --help-submit
        A guide for submitting test results to the developer, so that more
        terminal types will be recognized.
