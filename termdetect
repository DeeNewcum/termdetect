#!/usr/bin/perl

# There are several ANSI escape codes that can be used between the server and client for
# query/reply.  This utility shows how your current terminal responds to a particular query.

    use strict;
    use warnings;

    use Time::HiRes qw[alarm];
    #use Term::ReadKey;

    use Data::Dumper;


    # constants
    our $ASYNC = 1;     # Should reads be done asynchronously?
                        # If things are confusing AT ALL, just set this to 0 and debug from there.
                        # In theory, both modes should act exactly the same (except synchronous
                        # takes longer).  However, async won't work correctly if the reads get
                        # misaligned.
    our $DEBUG = 0;

    # prototypes
    sub read_phase(&);

    # globals
    our @read_queue;




## cooked mode, echo off
#Term::ReadKey::ReadMode(2);
system 'stty', '-icanon', '-echo', 'eol', "\001";
$|++;

END {
    ## reset tty mode before exiting
    #Term::ReadKey::ReadMode(0);         
    system 'stty', 'icanon', 'echo', 'eol', chr(0);
}

ensure_cursor_position_supported();

read_phase {
    print "\r-------- replies --------\n"; };

run_and_display_test("\e[5n",           "DSR - device status report");
#run_and_display_test("\x9B5n",          "C1 version DSR");
run_and_display_test("\e[?15n",         "printer status report");
run_and_display_test("\e[c",            "DA - device attributes");
run_and_display_test("\eZ",             "DECID - identify terminal");
run_and_display_test("\e[>c",           "secondary device attributes");
run_and_display_test("\e[=c",           "tertiary device attributes");
run_and_display_test("\e[x",            "terminal parameters");
run_and_display_test("\5",              "ENQ - enquiry character");

read_phase {
    print "\n-------- replies, more obscure --------\n";};

run_and_display_test("\e[?6n",          "extended cursor position report");
run_and_display_test("\e[?50n",         "DSR - keyboard status");
run_and_display_test("\e[?20n",         "DSR - user-defined key status");
run_and_display_test("\e[21t",          "[dtterm] window title");
run_and_display_test("\e[20t",          "[dtterm] window's icon label");
run_and_display_test("\ek-\e\\",        "set title");
run_and_display_test("\ek-\e\\\e[21t",  "set + get title");
run_and_display_test("\e[14t",          "[dtterm] window size, in pixels");
run_and_display_test("\e[18t",          "[dtterm] window size, in characters");
run_and_display_test("\e[11t",          "[dtterm] window state (iconified, etc)");
run_and_display_test("\e[13t",          "[dtterm] window position (pixels)");
run_and_display_test("\e[19t",          "[dtterm] screen size, in characters");

read_phase {
    print "\n-------- no reply -- the only goal is to detect cursor movement --------\n";};
            # ie. the escape sequence gets displayed to the user
            # ie. the terminal's lexer doesn't know about this sequence

run_and_display_test("\e[=",            "application keypad mode");
run_and_display_test("\e[>",            "numeric keypad mode");
run_and_display_test("\e|",             "visual bell");
run_and_display_test("\e[7",            "save cursor and attributes");
run_and_display_test("\eg",             "visual bell");
run_and_display_test("\eP\e\\",         "DCS - device control string (blank)");
run_and_display_test("\eP\e[0m\e\\",    "DCS - device control string (SGR reset); must be non-zero to pass");
run_and_display_test("\e\%G",           "[ISO2022] select UTF8 character set");
run_and_display_test("\e*C",            "[ISO2022] designate G2 character set");
run_and_display_test("\e+C",            "[ISO2022] designate G3 character set");
run_and_display_test("\x9B0K",          "C1 version of erase to EOL");


read_phase {
    print "\n-------- unsure if these show any variance across terminals --------\n";};

run_and_display_test("\x00",            "character NULL -- padding... shouldn't display");
run_and_display_test("\e\\",            qq{"do nothing" sequence});
run_and_display_test("\x18",            "character CAN (cancel) -- shouldn't display");
run_and_display_test("\e[\x18",         "CAN (cancel), test #2");
run_and_display_test("\x1A",            "character SUB (substitute) -- maybe display...  varies");
run_and_display_test("\e[\x1A",         "SUB (substitute), test #2");


do_queued_async_reads();

exit;







# We use the cursor-position report a lot...   if that doesn't work, then things will get hung up
# and take way too long.
# Figure this out before we waste a lot of time.
sub ensure_cursor_position_supported {

    output("\e[6n");

    read_phase {
        my $reply = read_ansi_reply(1.0, qr/\e[^a-zA-Z]*[a-zA-Z]/);
        if (!defined($reply) || $reply !~ /\e\[\d+;\d+R$/s) {
            close STDOUT; select undef,undef,undef,0.001;
            die "Terminal is unable to report the cursor position.  This is required for many tests.\n";
        }
    };
}


sub run_and_display_test {
    my ($sequence, $description) = @_;

    run_test($sequence, sub {
        my ($response) = @_;
        print "\r" unless $ASYNC;     # jump back to beginning of line
        printf  "%-15s %-25s %s\n",
                ansi_escape($sequence),
                ansi_escape($response),
                $description;
    });
}



# From the outside, this routine merely sense an ANSI query, and reads the reply.
# Internally though, we do it a somewhat fairly sophisticated way.  We surround the request with a
# CPR queries both before and after, which means that 1) we know if the query caused the cursor
# to move, and 2) if the terminal doesn't send any reply at all, we know that too, without having
# to do any waiting.
sub run_test {
    my ($sequence, $cps) = @_;
    $cps ||= sub{};     # CPS = continuation-passing style


    if ($sequence =~ /^(?:\e\[|\x9B)\??6n$/) {
        # run_test() isn't designed to work with a Cursor Position Report command.  This is because
        # it uses a CPR-reply as a way to know when to stop reading.
        #
        # When we're asked to do a CPR sequence, we'll revert to much dumbed-down behavior instead.
        
        output("\r", $sequence,
              "\e[5n");      # add a DSR (device status report) to the end, so we can at least
                            # quickly determine a non-response
                            
        read_phase {
            my $reply = read_ansi_reply(1.0, 'n');
            $reply =~ s/\e\[\d+n$//s;
            @_ = $reply;  goto &$cps;       # continuation-passing style
        };
        return;
    }

    output("\r", "\e[6n", $sequence, "\e[6n");      # send a CPR (cursor position report) before and after
    #debug_show_remaining_input();

    read_phase {
        my $replies = '';
        while (1) {
            $replies .= read_ansi_reply(0, 'R') or last;

            if ($replies =~ /.*\e\[(\d+);(\d+)R(.*)\e\[(\d+);(\d+)R/s) {
                my $x_delta = $5 - $2;
                my $y_delta = $4 - $1;
                my $response = $3;

                die "line wrap -- we don't know how to handle this\n" if ($y_delta != 0);
                if ($x_delta != 0) {
                    @_ = "[+$x_delta]";  goto &$cps;    # continuation-passing style
                } else {
                    @_ = $response;  goto &$cps;    # continuation-passing style
                }
            }
        }
    };
}




# Gets an ANSI response, reading only as many characters as necessary, and waiting only as long
# as necessary.
#
# $timeout
#       Seconds to wait for a reply.  Use 0 for no timeout.
#
# $response_end_character
#       If we see this character, we know the response is finished.
#
#       Special values:
#           - empty string -- means "read one buffer's worth of data".
#           - undef -- means "there is no specific end-character...  read until timeout
#           - regexp reference -- match several characters, not just one
#                   (use the "qr" quote-like operator)
sub read_ansi_reply {
    my ($timeout,
        $response_end_character) = @_;

    $timeout = 1.0 unless defined($timeout);

    my $reply = '';
    eval {
        local $SIG{ALRM} = sub { die "alarm\n" };
        alarm($timeout)     if ($timeout != 0);

        if (defined($response_end_character) && $response_end_character eq '') {
            # an empty-string means "read everything that's in the buffer"...  this assumes that
            # the response will be sent all-at-once, and that there will be a slight timegap in between
            # the response and anything else the terminal sends to us
            my $numchars = sysread(STDIN, $reply, 1024);
            $reply = substr($reply, 0, $numchars);
        } else {
            while (1) {
                if (defined(my $c = getc())) {
                    #print ".";
                    $reply .= $c;
                    if (defined($response_end_character)) {
                        if (ref($response_end_character) eq 'Regexp') {
                            last if ($reply =~ $response_end_character);
                        } else {
                            last if ($c eq $response_end_character);
                        }
                    }
                }
            }
        }
    };
    die $@ if ($@ && $@ ne "alarm\n");
    alarm 0;
    print "read response:  ", ansi_escape($reply), "\n"     if ($DEBUG);
    return $reply;
}



# There are two phases to every ANSI test:  1) write phase, 2) read phase.
#
# If we do all of the read phases AFTER doing all of the write phases (ie. do the reads
# asynchronously), then the whole process goes much faster.  We minimize latency by doing this.
sub read_phase(&) {
    my ($callback) = @_;
    if ($ASYNC) {
        # run the callback asynchronously
        push(@read_queue, $callback);
    } else {
        # run the callback immediately, in-line
        $callback->();
    }
    return undef;
}


sub do_queued_async_reads {
    while (@read_queue) {
        shift(@read_queue)->();
    }
}





sub debug_show_remaining_input {
    print "---- debug_show_remaining_input ----\n";
    while (my $reply = read_ansi_reply(0, '')) {
        print ansi_escape($reply), "\n";
    }
    exit;
}


sub output {
    print "sending: ", ansi_escape(join "", @_), "\n"       if ($DEBUG);
    print @_;
}



sub ansi_escape { map {(my $a = $_);
        $a =~ s/\\/\\\\/g;
        $a =~ s/\e/\\e/g;
        $a =~ s/\x5/\\5/g;
        $a =~ s/\x9B/\\x9B/g;
        $a =~ s/([\x00-\x1f])/"\\x" . sprintf "%02X", ord($1)/ge;
        $a} @_ }


# display a string to the user, via `xxd`
sub xxd {open my$xxd,"|xxd"or die$!;print$xxd $_[0];close$xxd}




# Copyright (C) 2012  Dee Newcum
# https://github.com/DeeNewcum/
#
# You may redistribute this program and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
