#!/usr/bin/perl

# something odd is happening in atypical_chars_search, and it seems to have 1) random timing, and
# 2) depend on the terminal we're talking to.
#
#       (see "stuck_negative" within atypical_chars_search)
#
# This program explores one possible problem we might be running into.

    use strict;
    use warnings;

    use Time::HiRes qw(time);

    use Data::Dumper;
    #use Devel::Comments;           # uncomment this during development to enable the ### debugging statements
    
    our $DEBUG = 0;


cooked_mode();
flood_ping_terminal(999999);




# Ping the terminal as fast as possible.
# Returns the average latency  (in milliseconds)
sub flood_ping_terminal {
    my ($num_packets) = @_;

    my $count = 0;

    my @rtts;
    my $sequence_number = 1;
    while ($num_packets-- > 0) {
        $count++;
        my $start = time();
        output("\e[${sequence_number}G\e[6n");
        my $reply = read_ansi_reply(5.0, qr/\e\[\d+;${sequence_number}R/);
        defined($reply) or die "timeout after $count packets\n";
        my $end = time();
        my $rtt;
        if ($reply =~ /^\e\[\d+;${sequence_number}R/s) {
            $rtt = int(($end - $start) * 1000);
            
            if ($rtt > 100) {
                die "exceptionally long ping time ($rtt ms) after $count packets\n";
            }

            #push(@rtts, $rtt);
        } else {
            die "out of sync after $count packets\n";
        }
        $sequence_number = ($sequence_number % 40) + 1;
        sleep(4 * $rtt / 1000);     # we actually have to delay slightly, or TCP seems to slow down after 3 or 4 packets
    }
    output("\r");
    #print Dumper \@rtts;

    # return the average of the ping times
    return sum(@rtts) / scalar(@rtts);
}

sub output {
    print STDERR @_;
    #print @_;
}


# Gets an ANSI response, reading only as many characters as necessary, and waiting only as long
# as necessary.
#
# $timeout
#       Seconds to wait for a reply.  Use 0 for no timeout.
#
# $response_end_character
#       If we see this character, we know the response is finished.
#
#       Special values:
#           - empty string -- means "read one buffer's worth of data".
#           - undef -- means "there is no specific end-character...  read until timeout
#           - regexp reference -- match several characters, not just one
#                   (use the "qr" quote-like operator)
sub read_ansi_reply {
    my ($timeout,
        $response_end_character) = @_;

    $timeout = 1.0 unless defined($timeout);

    my $reply = '';
    eval {
        local $SIG{ALRM} = sub { die "alarm\n" };
        alarm($timeout)     if ($timeout != 0);

        if (defined($response_end_character) && $response_end_character eq '') {
            # an empty-string means "read everything that's in the buffer"...  this assumes that
            # the response will be sent all-at-once, and that there will be a slight timegap in between
            # the response and anything else the terminal sends to us
            my $numchars = sysread(STDIN, $reply, 1024);
            $reply = substr($reply, 0, $numchars);
        } else {
            while (1) {
                if (defined(my $c = getc())) {
                    #print ".";
                    $reply .= $c;
                    if (defined($response_end_character)) {
                        if (ref($response_end_character) eq 'Regexp') {
                            last if ($reply =~ $response_end_character);
                        } else {
                            last if ($c eq $response_end_character);
                        }
                    }
                }
            }
        }
    };
    return undef if ($@ && $@ eq "alarm\n");
    die $@ if ($@ && $@ ne "alarm\n");
    alarm 0;
    print "read response:  ", ansi_escape($reply), "\n"     if ($DEBUG);
    return $reply;
}




# put the terminal in cooked mode   (and make sure it gets changed back before the program exits)   
sub cooked_mode {
    ## cooked mode, echo off
    #Term::ReadKey::ReadMode(2);
    system 'stty', '-icanon', '-echo', 'eol', "\001";
    $|++;

    eval q{
        END {
            ## reset tty mode before exiting
            #Term::ReadKey::ReadMode(0);         
            system 'stty', 'icanon', 'echo', 'eol', chr(0);
        }
    };
}


