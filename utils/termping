#!/usr/bin/perl

# Estimate the round-trip time to get a response from the terminal.
#
# Caveats:  Latency != throughput.
#
#           Also, note that this doesn't represent the latency to the end-user's terminal if you're
#           running things like tmux/screen/mosh.  Each of those have their own VT translation
#           layer, and they respond to pings on their own.  So if you have:
#
#               terminal  <==>    tmux  <==>  termping
#                 (US)          (China)        (China)
#           
#           you're going to see 0ms time.  That can be deceiving unless you realize that you're
#           really measuring the ping time to tmux.
#
#           Also, this is a TCP-based ping, which means that some response times may be greatly
#           inflated for several reasons including retransmission and congestion control
#           (exponential backoff can CERTAINLY skew the results).

    use strict;
    use warnings;

    use Time::HiRes qw[time sleep alarm];

    use Data::Dumper;



## cooked mode, echo off
#Term::ReadKey::ReadMode(2);
system 'stty', '-icanon', '-echo', 'eol', "\001";
$|++;

END {
    ## reset tty mode before exiting
    #Term::ReadKey::ReadMode(0);         
    system 'stty', 'icanon', 'echo', 'eol', chr(0);
}


if (0) {
    my $began_pinging = time();
    my $num_packets = 20;
    my $latency = flood_ping_terminal($num_packets);
    my $total_time  = time() - $began_pinging;
    printf "flood pinging %d packets took   %d ms,   and measured   %d ms   average latency.\n",
                $num_packets, $total_time *1000, $latency;
    exit;
}


my @last20;
my ($min, $max) = (9999999, -1);
my $sequence_number = 1;
while (1) {
    my $start = time();
    print "\e[${sequence_number}G\e[6n";
    my $reply = read_ansi_reply(1.0, qr/\e\[\d+;${sequence_number}R/);
    my $end = time();
    print "\r";
    if ($reply =~ /^\e\[\d+;${sequence_number}R/s) {
        my $rtt = int(($end - $start) * 1000);
        $min = min($min, $rtt);
        $max = max($max, $rtt);
        push(@last20, $rtt);
        splice(@last20, 0, -20);
        my $avg = @last20 ? sum(@last20) / scalar(@last20) : 0;
        printf "%4d ms    (min %d,  max %d,   avg %.1f)\n",
                $rtt, $min, $max, $avg;
    } else {
        print "  XX\n";
    }
    sleep(0.5);
    $sequence_number = ($sequence_number % 40) + 1;
}



# Ping the terminal as fast as possible.
# Returns the average latency  (in milliseconds)
sub flood_ping_terminal {
    my ($num_packets) = @_;

    my @rtts;
    my $sequence_number = 1;
    while ($num_packets-- > 0) {
        my $start = time();
        print "\e[${sequence_number}G\e[6n";
        my $reply = read_ansi_reply(1.0, qr/\e\[\d+;${sequence_number}R/);
        my $end = time();
        my $rtt;
        if ($reply =~ /^\e\[\d+;${sequence_number}R/s) {
            $rtt = int(($end - $start) * 1000);
            push(@rtts, $rtt);
        } else {
            #print "  XX\n";
        }
        $sequence_number = ($sequence_number % 40) + 1;
        sleep(4 * $rtt / 1000);     # we actually have to delay slightly, or TCP seems to slow down after 3 or 4 packets
    }
    print "\r";
    #print Dumper \@rtts;

    # return the average of the ping times
    return sum(@rtts) / scalar(@rtts);
}



# Gets an ANSI response, reading only as many characters as necessary, and waiting only as long
# as necessary.
#
# $timeout
#       Seconds to wait for a reply.  Use 0 for no timeout.
#
# $response_end_character
#       If we see this character, we know the response is finished.
#
#       Special values:
#           - empty string -- means "read one buffer's worth of data".
#           - undef -- means "there is no specific end-character...  read until timeout
#           - regexp reference -- match several characters, not just one
#                   (use the "qr" quote-like operator)
sub read_ansi_reply {
    my ($timeout,
        $response_end_character) = @_;

    $timeout = 1.0 unless defined($timeout);

    my $reply = '';
    eval {
        local $SIG{ALRM} = sub { die "alarm\n" };
        alarm($timeout)     if ($timeout != 0);

        if (defined($response_end_character) && $response_end_character eq '') {
            # an empty-string means "read everything that's in the buffer"...  this assumes that
            # the response will be sent all-at-once, and that there will be a slight timegap in between
            # the response and anything else the terminal sends to us
            my $numchars = sysread(STDIN, $reply, 1024);
            $reply = substr($reply, 0, $numchars);
        } else {
            while (1) {
                if (defined(my $c = getc())) {
                    #print ".";
                    $reply .= $c;
                    if (defined($response_end_character)) {
                        if (ref($response_end_character) eq 'Regexp') {
                            last if ($reply =~ $response_end_character);
                        } else {
                            last if ($c eq $response_end_character);
                        }
                    }
                }
            }
        }
    };
    die $@ if ($@ && $@ ne "alarm\n");
    alarm 0;
    return $reply;
}



# List::Util
{no strict; sub reduce(&@) {$s=shift;@_>1||return$_[0];$c=caller;local(*{$c."::a"})=\my$a;local(*{$c."::b"})=\my$b;$a=shift;for(@_){$b=$_;$a=&{$s}()}$a}}
sub sum  { reduce { $a + $b } @_ }
sub min  { reduce { $a < $b ? $a : $b } @_ }
sub max  { reduce { $a > $b ? $a : $b } @_ }
sub minstr  { reduce { $a lt $b ? $a : $b } @_ }
sub maxstr  { reduce { $a gt $b ? $a : $b } @_ }
