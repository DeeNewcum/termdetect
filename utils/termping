#!/usr/bin/perl

# Estimate the round-trip time to get a response from the terminal.
#
# Caveats:  Latency != throughput.
#           Also, note that this doesn't represent the latency to the end-user's terminal if you're
#           running things like tmux/screen/mosh.  Each of those have their own VT translation
#           layer, and they respond to pings on their own.  So if you have:
#
#               terminal  <==>    tmux  <==>  termping
#                 (US)          (China)        (China)
#           
#           you're going to see 0ms time.  That can be deceiving unless you realize that you're
#           really measuring the ping time to tmux.

    use strict;
    use warnings;

    use Time::HiRes qw[time sleep alarm];

    use Data::Dumper;



## cooked mode, echo off
#Term::ReadKey::ReadMode(2);
system 'stty', '-icanon', '-echo', 'eol', "\001";
$|++;

END {
    ## reset tty mode before exiting
    #Term::ReadKey::ReadMode(0);         
    system 'stty', 'icanon', 'echo', 'eol', chr(0);
}



my @last20;
my ($min, $max) = (9999999, -1);
while (1) {
    my $start = time();
    print "\e[5n";
    my $reply = read_ansi_reply(1.0, 'n');
    my $end = time();
    if ($reply =~ /^\e\[[^\ea-z]*n/s) {
        my $rtt = int(($end - $start) * 1000);
        $min = min($min, $rtt);
        $max = max($max, $rtt);
        push(@last20, $rtt);
        splice(@last20, 0, -20);
        my $avg = @last20 ? sum(@last20) / scalar(@last20) : 0;
        printf "%4d ms    (min %d,  max %d,   avg %.1f)\n",
                $rtt, $min, $max, $avg;
    } else {
        print "  XX\n";
    }
    sleep(0.5);
}



# Gets an ANSI response, reading only as many characters as necessary, and waiting only as long
# as necessary.
#
# $timeout
#       Seconds to wait for a reply.  Use 0 for no timeout.
#
# $response_end_character
#       If we see this character, we know the response is finished.
#
#       Special values:
#           - empty string -- means "read one buffer's worth of data".
#           - undef -- means "there is no specific end-character...  read until timeout
#           - regexp reference -- match several characters, not just one
#                   (use the "qr" quote-like operator)
sub read_ansi_reply {
    my ($timeout,
        $response_end_character) = @_;

    $timeout = 1.0 unless defined($timeout);

    my $reply = '';
    eval {
        local $SIG{ALRM} = sub { die "alarm\n" };
        alarm($timeout)     if ($timeout != 0);

        if (defined($response_end_character) && $response_end_character eq '') {
            # an empty-string means "read everything that's in the buffer"...  this assumes that
            # the response will be sent all-at-once, and that there will be a slight timegap in between
            # the response and anything else the terminal sends to us
            my $numchars = sysread(STDIN, $reply, 1024);
            $reply = substr($reply, 0, $numchars);
        } else {
            while (1) {
                if (defined(my $c = getc())) {
                    #print ".";
                    $reply .= $c;
                    if (defined($response_end_character)) {
                        if (ref($response_end_character) eq 'Regexp') {
                            last if ($reply =~ $response_end_character);
                        } else {
                            last if ($c eq $response_end_character);
                        }
                    }
                }
            }
        }
    };
    die $@ if ($@ && $@ ne "alarm\n");
    alarm 0;
    return $reply;
}



# List::Util
{no strict; sub reduce(&@) {$s=shift;@_>1||return$_[0];$c=caller;local(*{$c."::a"})=\my$a;local(*{$c."::b"})=\my$b;$a=shift;for(@_){$b=$_;$a=&{$s}()}$a}}
sub sum  { reduce { $a + $b } @_ }
sub min  { reduce { $a < $b ? $a : $b } @_ }
sub max  { reduce { $a > $b ? $a : $b } @_ }
sub minstr  { reduce { $a lt $b ? $a : $b } @_ }
sub maxstr  { reduce { $a gt $b ? $a : $b } @_ }
