#!/usr/bin/perl

# development testbed for creating a terminfo lexer/parser

    use strict;
    use warnings;

    use Const::Fast;

    use Data::Dumper;
    #use Devel::Comments;           # uncomment this during development to enable the ### debugging statements

    our $last_pos;
    our $lines;


my $terminfo = slurp("terminfo.src");
parse_terminfo($terminfo);

# terminfo(5) says of terminfo's syntax:
#
#      Entries  in  terminfo  consist  of  a  sequence of "," separated fields
#      (embedded commas may be escaped with a backslash or notated  as  \054).
#      White  space  after  the "," separator is ignored.  The first entry for
#      each terminal gives the names which are known for the  terminal,  sepa-
#      rated  by  "|"  characters.   The  first  name given is the most common
#      abbreviation for the terminal, the last name given  should  be  a  long
#      name  fully  identifying the terminal, and all others are understood as
#      synonyms for the terminal name.  All names but the last  should  be  in
#      lower  case and contain no blanks; the last name may well contain upper
#      case and blanks for readability.
#
#      A  number  of  escape  sequences   are  provided  in  the  string valued
#      capabilities for easy encoding of characters there.  Both \E and \e map
#      to  an  ESCAPE character, ^x maps to a control-x for any appropriate x,
#      and the sequences \n \l \r \t \b  \f  \s  give  a  newline,  line-feed,
#      return, tab, backspace, form-feed, and space.  Other escapes include \^
#      for ^, \\ for \, \, for comma, \: for :, and \0  for  null.   (\0  will
#      produce  \200,  which does not terminate a string but behaves as a null
#      character on most terminals, providing CS7 is specified.  See stty(1).)
#      Finally, characters may be given as three octal digits after a \.
#
#      Sometimes  individual  capabilities must be commented out.  To do this,
#      put a period before the capability name.  For example, see  the  second
#      ind in the example above.
#
#      Numeric  capabilities are followed by the character "#" and then a
#      positive value.
#
#      String valued capabilities, such as el (clear to end of line sequence)
#      are given by the two-character code, an "=", and then a string ending
#      at the next following ",".
#
# The Single UNIX Specification further says:
#
#      Each description consists of a header (beginning in column 1) and one
#      or more lines that list the features for that particular device. Every
#      line in a terminfo source file must end in a comma. Every line in a
#      terminfo source file except the header must be indented with one or
#      more white spaces (either spaces or tabs).
#
#      Entries in terminfo source files consist of a number of
#      comma-separated fields. White space after each comma is ignored. 
#
sub parse_terminfo  {
    #my ($lines) = @_;
    ($lines) = @_;      # it would be "my ($lines)" if it weren't for lexdebug()

    my $lineno = 1;
    my @fields;
    while (1) {
        $last_pos = pos($lines);

        my $at_newline = $lines =~ /\G(?<=\n)/gc;
        if ($lines =~ /\G\n/gc) {
            #lexdebug("newline");
            $lineno++;
            next;
        }
        if ($lines =~ /\G(?:(?<=\n)|^)#\V*/gc) {
            # comment
            #lexdebug("comment");
            next;
        }
        if ($lines =~ /\G(?<=\n)\h+/gc) {
            # line continuation
            #lexdebug("line continuation");
            next;
        }
        if ($lines =~ /\G(?!,)(?!\s)((?:[\\%^][^\n]|[^,\\%^\n])+),\h*/gc) {
            my $field = [$lineno, $1];
            #lexdebug("field");
            if ($at_newline) {
                process_fields(@fields)     if @fields;
                @fields = ($field);
            } else {
                push(@fields, $field);
            }
            next;
        }
        last if (pos($lines) == length($lines));        # done parsing

        print "$lineno: syntax error\n";
        exit;

        if (0) {
            if (defined(pos($lines))) {
                print xxd(substr($lines, pos($lines), 100));
                print "\nat position ", pos($lines), " of possible ",
                        length($lines), "\n";
            }
            exit;
        }
    }
    process_fields(@fields)     if @fields;
}


sub process_fields {
    my @fields = @_;

    my $terminal = shift @fields;

    my @termnames = grep {defined $_} $terminal->[1] =~ /^((?:[\\%^][^\n|]|[^,\\%^\n|])+)(?:\|((?:[\\%^][^\n|]|[^,\\%^\n|])+))*$/;
    
    print "================[ ", join(" --- ", @termnames), " ] ]================\n";

    foreach my $f (@fields) {
        my ($lineno, $field) = @$f;

        if ($field =~ /^((?:[\\%^][^\n]|[^,\\%^\n])+)(?:=((?:[\\%^][^\n]|[^,\\%^\n])+)|#(\d+))$/) {
            if ($2) {
                printf "%-20s  =  %s\n", $1, $2;
            } elsif ($3) {
                printf "%-20s  #  %s\n", $1, $3;
            }
        } else {
            print "$field\n";
        }
    }
}

#sub unescape_terminfo {
#    my ($field) = @_;
#
#    $field =~ s/
#}


sub lexdebug {
    #return;                 # use for speed tests
    my ($descr) = @_;

    my $cur_pos = pos($lines);
    0 && printf "%20s    %s\n",
        $descr,
        qquote(substr($lines, $last_pos, $cur_pos - $last_pos));
}
sub qquote {my$q=Data::Dumper::qquote($_[0]);$q=~s/^"//;$q=~s/"$//;$q}


# quickly read a whole file
sub slurp {my$p=open(my$f,"$_[0]")or die$!;my@o=<$f>;close$f;waitpid($p,0);wantarray?@o:join("",@o)}


# run a scalar through an external filter, and capture the results
# first arg is a list-ref that specifies the filter-command
use autodie;
sub filter_thru {my$pid=open my$fout,'-|'or do{my$pid=open my$fin,'|-',@{shift()};print$fin @_;close$fin;waitpid$pid,0;exit;};
                 my@o=<$fout>;close$fout;waitpid$pid,0;wantarray?@o:join'',@o}

sub xxd {filter_thru(['xxd'],@_)}

# display a string to the user, via 'less'
sub less {my$pid=open my$less,"|less";print$less @_;close$less;waitpid$pid,0}
