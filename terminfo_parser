#!/usr/bin/perl

# development testbed for creating a terminfo lexer/parser


# for the verification stage of this, you need to first run
# `tic` against the desired terminfo file, to populate your ~/.terminfo/ directory with the file under test



# TODO:
#       - this doesn't work on Perl 5.8...  figure out why it breaks...
#               - I suspect it's partly because 5.8 doesn't support 
#                 nested/re-entrant calls to the regexp engine

    use strict;
    use warnings;

    use constant UNIT_TEST => 1;     # set to true to validate our results against the official parser

    use Data::Dumper;
    #use Carp;

    use autodie;
    use Carp::Always;





our %num_dependencies;

my $terminfo = "terminfo.src";          # http://invisible-island.net/ncurses/ncurses.faq.html#which_terminfo
#my $terminfo = "termtypes.ti";          # http://www.catb.org/~esr/terminfo/

my $terminfo_contents = slurp($terminfo);
my $parsed = parse_terminfo($terminfo_contents);
#print dump_terminal(@$parsed); exit;
$parsed = flatten_terminfo($parsed);
#print Dumper $parsed; exit;
#print dump_terminal(values %$parsed); exit;
if (UNIT_TEST) {
    unittest__prepare_TERMINFO($terminfo);
    unittest_terminfo($parsed);
}


# terminfo(5) says of terminfo's syntax:
#
#      Entries  in  terminfo  consist  of  a  sequence of "," separated fields
#      (embedded commas may be escaped with a backslash or notated  as  \054).
#      White  space  after  the "," separator is ignored.  The first entry for
#      each terminal gives the names which are known for the  terminal,  sepa-
#      rated  by  "|"  characters.   The  first  name given is the most common
#      abbreviation for the terminal, the last name given  should  be  a  long
#      name  fully  identifying the terminal, and all others are understood as
#      synonyms for the terminal name.  All names but the last  should  be  in
#      lower  case and contain no blanks; the last name may well contain upper
#      case and blanks for readability.
#
#      A  number  of  escape  sequences   are  provided  in  the  string valued
#      capabilities for easy encoding of characters there.  Both \E and \e map
#      to  an  ESCAPE character, ^x maps to a control-x for any appropriate x,
#      and the sequences \n \l \r \t \b  \f  \s  give  a  newline,  line-feed,
#      return, tab, backspace, form-feed, and space.  Other escapes include \^
#      for ^, \\ for \, \, for comma, \: for :, and \0  for  null.   (\0  will
#      produce  \200,  which does not terminate a string but behaves as a null
#      character on most terminals, providing CS7 is specified.  See stty(1).)
#      Finally, characters may be given as three octal digits after a \.

#      ...
#
#      Sometimes  individual  capabilities must be commented out.  To do this,
#      put a period before the capability name.  For example, see  the  second
#      ind in the example above.

#      ...
#
#      Numeric  capabilities are followed by the character "#" and then a
#      positive value.

#      ...
#
#      String valued capabilities, such as el (clear to end of line sequence)
#      are given by the two-character code, an "=", and then a string ending
#      at the next following ",".
#       
#      ...
#
#      The % encodings have the following meanings:
#               (read terminfo(5) for full info about % encodings)
#
# The Single UNIX Specification further says:
#
#      Each description consists of a header (beginning in column 1) and one
#      or more lines that list the features for that particular device. Every
#      line in a terminfo source file must end in a comma. Every line in a
#      terminfo source file except the header must be indented with one or
#      more white spaces (either spaces or tabs).
#
#      Entries in terminfo source files consist of a number of
#      comma-separated fields. White space after each comma is ignored. 
#
sub parse_terminfo  {
    my ($lines) = @_;

    my @parsed;

    my @lines = split /\n/, $lines;
    our @process_fields;
    for (our $lineno=0; $lineno<@lines; $lineno++) {
        our %field = (lineno => $lineno);
        our @fields = ();
        our $is_continuation;
        $lines[$lineno] =~ m{
              ^ \# .*           # ignore comment lines
            | ^ \h* $           # ignore blank lines
            | ^( \h* )
                                    (?{ $is_continuation = length $^N    })
                (?:
                    (?! \h )
                    ((?:  \\\d\d\d  |  [\\^][^\n]  |  [^,\\^\n=\#]  )+)
                       #  ^^^^^^^^     ^^^^^^^^     ^^^^^^^^^^^    various escape codes
                                    (?{ local $field{capability} = $^N   })
                    (?:     = ((?:  \\\d\d\d  |  [\\^][^\n]  |  [^,\\^\n]  )*)
                              ## same as above, but with [=\#] removed, and + changed to *
                                    (?{ local $field{assign} = $^N    })
                         | \# (\d+)
                                    (?{ local $field{num} = $^N    })
                         )?
                    , \h*  
                                    (?{ push(@fields, {%field})   })
                )+ $
        }x
            or die "syntax error on line " . ($lineno+1) . "\n\t$lines[$lineno]\n";

        if (defined($is_continuation)) {
            if ($is_continuation) {
                push(@process_fields, @fields);
            } else {
                push(@parsed, process_fields(@process_fields)) if (@process_fields);
                @process_fields = (@fields);
            }
        }
    }
    push(@parsed, process_fields(@process_fields)) if (@process_fields);

    return \@parsed;
}


sub process_fields {
    my @fields = @_;

    my $termfield = shift @fields;

    my @termnames = split /\|/, $termfield->{capability};
    my $descr = pop @termnames      if (@termnames >= 2);
    my %parsed = (
        termnames      => \@termnames,
        term_descr     => $descr,
        lineno_range   => [         # range of line numbers that this entry occupies
                $termfield->{lineno},       # first line
                $fields[-1]{lineno},        # last line
            ],
        );

    $parsed{fields} = [
            map {
                $_->{assign} = terminfo_unescape($_->{assign})      if $_->{assign};
                $_
            } @fields
        ];

    return \%parsed;
}


BEGIN {
    our %escapes = (

        "\\a"  => "\x07",   # bell
        "\\b"  => "\x08",   # backspace
        "\\f"  => "\x0c",   # form feed
        "\\e"  => "\e",     # escape
        "\\l"  => "\x0a",   # line feed
        "\\n"  => "\x0a",   # newline
        "\\r"  => "\x0d",   # return
        "\\s"  => " ",      # space
        "\\t"  => "\t",     # horizontal tab
        "\\0"  => "\200",   # null   (see detailed info about this in terminfo(5)...   it's not clear to me why we use \200 instead of \x00)

        "^\\"  => "\x1c",
        "^]"   => "\x1d",
        "^^"   => "\x1e",
        "^_"   => "\x1f",

        # plain escapes
        "\\,"  => ",",
        "\\:"  => ":",
        "\\\\" => "\\",
        "\\^"  => "^",
    );
    for ('a'..'z') {
        $escapes{"^$_"} = chr(ord($_) - 96);
    }
    #print Dumper \%escapes; exit;


# The output of this should EXACTLY match tigetstr(3).
# That is -- the percent parameters haven't been expanded (it doesn't do what tparm() does), but
# all other escape-codes should be expanded.
sub terminfo_unescape {
    local $_ = shift;

    s/
        \\(\d\d\d)    |
        (\%)(?=\\)    |         # i have no clue what the fuck this is...  but this is required to match the official parser's behavior
        ([\\^].)      |
        \%{(\d\d+)}   |
        \%'([^']+)'   |
        (%'[^']+'|%.)
    /
            defined($1) ? chr(oct($1))
          : defined($2) ? $2
          : defined($3) ? ($escapes{lc $3} || substr($3, -1))
          : defined($4) ? unescape_percent_char($4)
          : defined($5) ? ("%'" . terminfo_unescape($5) . "'")
          : defined($6) ? $6 : "YOUBROKEIT"
        /gex;
    return $_;
}
}

    sub unescape_percent_char {
        my $charnum = shift;
        if ($charnum >= 32 && $charnum <= 126 && $charnum != 92) {
            return "\%'" . chr($charnum) . "'";
        } else {
            return "\%{$charnum}";
        }
    }


# The terminfo specification allows for use= clauses (and @ items to cancel things inside uses).
# This takes the parsed fields that contain use= clauses, and flattens everything out so you don't
# have to do a lot of work to find out what the final values for a given $TERM are.
sub flatten_terminfo {
    my ($parsed) = @_;

    eval 'use Term::Terminfo';
    $@ and die "the unit test requires Term::Terminfo to be installed\n\t";

    ## gather up all aliases
    my %canonical_name;     # mapping from   canonical_name => entry_structure
    my %all_term_names;     # mapping from   alias => canonical_name
    foreach my $entry (@$parsed) {
        my $canonical = $entry->{termnames}[0];

        $canonical_name{$canonical} = $entry;
        foreach my $termname (@{$entry->{termnames}}) {
            $all_term_names{$termname} = $canonical;
        }
    }

    ## gather up all "use" entries
    my %first_level_uses;
    foreach my $entry (@$parsed) {
        my $canonical = $entry->{termnames}[0];
        foreach my $field (@{$entry->{fields}}) {
            if ($field->{capability} eq 'use') {
                push @{$first_level_uses{$canonical}}, $field->{assign};
            }
        }
    }

    #print Dumper $canonical_name{'vt220+keypad'};  exit;

    ## now, merge all the capabilities in the proper precedence order
    my %flattened;
    foreach my $canonical (keys %canonical_name) {
    #foreach my $canonical ('abm85e') {
    #foreach my $canonical ('vt220+keypad') {
    #foreach my $canonical ('screen.rxvt') {
        # recursively explore the tree
        my $merged = merge_tree($canonical,
                                {},
                                \%canonical_name,
                                \%all_term_names,
                                \%first_level_uses,
                                $canonical);

        # actually delete all entries that are explicitely marked "deleted"
        while (my ($cap, $field) = each %$merged) {
            delete $merged->{$cap} if (!defined($field));
        }

        $flattened{$canonical} = {
            %{$canonical_name{$canonical}},
            fields => $merged,
        };
    }
    #exit;
    #print dump_terminal($flattened{abm85e}); exit;
    #print dump_terminal(values %flattened);  exit;
                
    ## add aliases
    #return \%flattened;
    while (my ($alias, $canonical) = each %all_term_names) {
        if (!exists $flattened{$alias}) {
            $flattened{$alias} = {
                alias => $canonical,
                termnames => [$alias],      # $flattened{$canonical}{termnames},
            };
        }
    }
    #print dump_terminal(values %flattened);  exit;

    return \%flattened;
}



# recursively explore the tree, merging the fields for a specific entry
#       %$terms_seen gets built from top-down
#       %$merged gets built from bottom-up
sub merge_tree {
    my ($term,                  # the specific terminal to return the list of merged fields for
        $terms_seen,            # all terminals seen so far, when exploring the tree
                                #           (note: this lists ONLY the parent nodes, in direct
                                #           lineage...  it does NOT list siblings of parents)
        @passthru) = @_;

    my ($canonical_name,        # mapping from   canonical_name => entry_structure
        $all_term_names,        # mapping from   alias => canonical_name
        $first_level_uses,      # mapping from   canonical_name => ordered list of "use" entries for this level ONLY
        $orig_term,             # the $term from the first-level call to this
        ) = @passthru;

    #my $rlevel = scalar(keys %$terms_seen);     # for debugging only -- current recursion level
    #my $indent = "\t" x $rlevel;

    $num_dependencies{$orig_term}++;

    # according to terminfo(5):
    #           "The capabilities given before use override those in the base type named by use.
    #           If there are multiple use capabilities, they are merged in reverse order.
    #           That is, the rightmost use reference is processed first, then the one to its
    #           left, and so forth.  Capabilities given explicitly in the entry override
    #           those brought in by use references."
    my $merged = {};
    my %terms_seen = (%$terms_seen, $term => 1);
    foreach my $use (reverse @{$first_level_uses->{$term} || []}) {
        $use = $all_term_names->{$use};         # canonicalize
        next if ($terms_seen{$use});            # avoid infinite loops
        my $subtree = merge_tree($use, \%terms_seen, @passthru);          # recursion step -- call ourselves
        $merged = merge_fields($merged, $subtree);
    }
    $merged = merge_fields($merged, 
                     field__list_to_hash(  $canonical_name->{$term}{fields}  ));

    return $merged;
}


# merge two sets of fields, with the "$a" one taking precedent over "$b"
sub merge_fields {
    my $a = field__list_to_hash(shift);
    my $b = field__list_to_hash(shift);

    my %merged = %$a;

    while (my ($cap, $field) = each %$b) {
        #next if defined($merged{$cap});     # if there's already a value here, we're not going
                                            # to overwrite it
        if ($cap eq 'use') {
            next;       # we're handling the hierarchy elsewhere
        } elsif ($cap =~ s/\@$//) {
            # explicitely mark this as "deleted" -- we need a placeholder for these, since 
            # we're going to be processing lower-down ones
            #$merged{$cap} = { capability => $cap, deleted => 1};
            delete $merged{$cap};
        } else {
            $merged{$cap} = $field;
        }
    }
    return \%merged;
}

        # convert a list-ref of fields into a hash-ref of fields
        #       (or, if already a hash-ref...  just return it untouched)
        sub field__list_to_hash {
            my ($field_list) = @_;
            return $field_list  if ref($field_list) eq 'HASH';
            return {
                    map {$_->{capability} => $_}
                        @$field_list
                   };
        }





    

# point $ENV{TERMINFO} to the right place
#       (and compile the terminfo file if necessary)
sub unittest__prepare_TERMINFO {
    my ($terminfo_filename) = @_;

    my $terminfo_dir = "$ENV{HOME}/.terminfo.$terminfo_filename/";
    if (!-d $terminfo_dir) {
        system "tic", "-o$terminfo_dir", $terminfo_filename;
        $? == -1    and die "unable to run 'tic'\n";
    }

    $ENV{TERMINFO} = $terminfo_dir;
}


# a unit test to confirm our parser matches tic(1)'s parser
sub unittest_terminfo {
    my ($parsed) = @_;

    if (ref($parsed) eq 'HASH') {
        $parsed = [ values %$parsed ];
    }

    foreach my $entry (sort {$a->{termnames}[0] cmp $b->{termnames}[0]} @$parsed) {
        next if ($entry->{alias});
        next if ($entry->{fields}{hc});     # Term::Terminfo doesn't like hardcopy entries
        next if ($entry->{fields}{gn});     # Term::Terminfo doesn't like generic entries


        print "================[ ", join(" -- ", @{$entry->{termnames}}, $entry->{term_descr} || ''),
                    " ]================\n";
    
        print "dependencies:  $num_dependencies{$entry->{termnames}[0]}\n";
        #next if ($num_dependencies{$entry->{termnames}[0]} > 3);
        #print "\t", join(", ", @{$precedence{$entry->{termnames}[0]}}), "\n";
        #next unless (@{$precedence{$entry->{termnames}[0]}} == 2);
            # terminals that currently have parse errors, but have only two 'use=' entries TOTAL:
            #       abm85h
            #       avt-rv
            #       avt-w

        my $terminfo = Term::Terminfo->new($entry->{termnames}[0]);
        my $fields = [ sort { dump_sort_fields() } values %{$entry->{fields}} ];
        #while (my ($cap, $field) = each %{$entry->{fields}}) {
        foreach my $field (@$fields) {
            my $cap = $field->{capability};

            do {        # modified version of dump_field($field)
                printf "%20s", $field->{capability};
                if ($field->{assign}) {
                    print " = ", qquote($field->{assign});
                } elsif ($field->{num}) {
                    print " # ", qquote($field->{num});
                }
            };

            if ($field->{assign}) {
                $cap =~ s/^OT//;        # see "obsolete" in the terminfo.src
                my $actual = $terminfo->getstr($cap) || '';
                if ($actual && $actual ne $field->{assign}) {
                    print "\t\tERROR\n";
                    printf "%-20s   %s\n", "", qquote($actual);
                }
            }
            print "\n";
        }

        print "\n";
    }
}


sub dump_terminal {
    my @terms = sort {$a->{termnames}[0] cmp $b->{termnames}[0]} @_;
    my $return = '';
    foreach my $terminal (@terms) {
        $return .= "================[ " . join(" -- ", @{$terminal->{termnames}}, $terminal->{term_descr} || '') .
                    " ]================\n";
        if ($terminal->{alias}) {
            #printf "%20s   %s\n\n", "alias of", $terminal->{alias};
            next;
        }

        my $fields = $terminal->{fields};
        if (ref($fields) eq 'HASH') {
            $fields = [ sort { dump_sort_fields() } values %$fields ];
        }
        $return .= dump_field(@$fields);
        $return .= "\n";
    }
    return $return;
}


sub dump_field {
    my $return = '';
    foreach my $field (@_) {
        next if (!defined($field));
        if (!exists $field->{capability}) {
            #confess("broke on: " . Dumper(\@_) . "\t");
            die;
            exit;
        }
        $return .= sprintf "%20s", $field->{capability};
        if ($field->{assign}) {
            $return .= " = " . qquote($field->{assign}) . "\n";
        } elsif ($field->{num}) {
            $return .= " # " . qquote($field->{num}) . "\n";
        } elsif ($field->{deleted}) {
            $return .= " XXXXXXXXXXX deleted\n";
        } else {
            $return .= "\n";
        }
    }
    return $return;
}


sub dump_sort_fields {
                        field_type($a) cmp field_type($b) ||
                        $a->{capability} cmp $b->{capability}
}


sub field_type {
    my ($field) = @_;
    return "3assign" if ($field->{assign});
    return "2num" if ($field->{num});
    return "1bool";
}


sub qquote {my$q=Data::Dumper::qquote($_[0]);$q=~s/^"(.*)"$/$1/s;$q}
sub _quote {my$q=Data::Dumper::_quote($_[0]);$q=~s/^'(.*)'$/$1/s;$q}


# indent all lines with the same character sequence
#           (even when there are multiple lines in the same scalar)
sub indent {my$i=shift;map {(my$a=$_) =~ s/^/$i/m;$a} @_}

# quickly read a whole file
sub slurp {my$p=open(my$f,"$_[0]")or die$!;my@o=<$f>;close$f;waitpid($p,0);wantarray?@o:join("",@o)}


# run a scalar through an external filter, and capture the results
# first arg is a list-ref that specifies the filter-command
use autodie;
sub filter_thru {my$pid=open my$fout,'-|'or do{my$pid=open my$fin,'|-',@{shift()};print$fin @_;close$fin;waitpid$pid,0;exit;};
                 my@o=<$fout>;close$fout;waitpid$pid,0;wantarray?@o:join'',@o}

sub xxd {filter_thru(['xxd'],@_)}

# display a string to the user, via 'less'
sub less {my$pid=open my$less,"|less";print$less @_;close$less;waitpid$pid,0}
