#!/usr/bin/perl

# development testbed for creating a terminfo lexer/parser

    use strict;
    use warnings;

    use Const::Fast;

    use Data::Dumper;
    #use Devel::Comments;           # uncomment this during development to enable the ### debugging statements

    our $last_pos;
    our $lines;


my $terminfo = slurp("terminfo.src");
parse_terminfo($terminfo);

# terminfo(5) says of terminfo's syntax:
#
#      Entries  in  terminfo  consist  of  a  sequence of "," separated fields
#      (embedded commas may be escaped with a backslash or notated  as  \054).
#      White  space  after  the "," separator is ignored.  The first entry for
#      each terminal gives the names which are known for the  terminal,  sepa-
#      rated  by  "|"  characters.   The  first  name given is the most common
#      abbreviation for the terminal, the last name given  should  be  a  long
#      name  fully  identifying the terminal, and all others are understood as
#      synonyms for the terminal name.  All names but the last  should  be  in
#      lower  case and contain no blanks; the last name may well contain upper
#      case and blanks for readability.
#
#      A  number  of  escape  sequences   are  provided  in  the  string valued
#      capabilities for easy encoding of characters there.  Both \E and \e map
#      to  an  ESCAPE character, ^x maps to a control-x for any appropriate x,
#      and the sequences \n \l \r \t \b  \f  \s  give  a  newline,  line-feed,
#      return, tab, backspace, form-feed, and space.  Other escapes include \^
#      for ^, \\ for \, \, for comma, \: for :, and \0  for  null.   (\0  will
#      produce  \200,  which does not terminate a string but behaves as a null
#      character on most terminals, providing CS7 is specified.  See stty(1).)
#      Finally, characters may be given as three octal digits after a \.
#
#      Sometimes  individual  capabilities must be commented out.  To do this,
#      put a period before the capability name.  For example, see  the  second
#      ind in the example above.
#
#      Numeric  capabilities are followed by the character "#" and then a
#      positive value.
#
#      String valued capabilities, such as el (clear to end of line sequence)
#      are given by the two-character code, an "=", and then a string ending
#      at the next following ",".
#
# The Single UNIX Specification further says:
#
#      Each description consists of a header (beginning in column 1) and one
#      or more lines that list the features for that particular device. Every
#      line in a terminfo source file must end in a comma. Every line in a
#      terminfo source file except the header must be indented with one or
#      more white spaces (either spaces or tabs).
#
#      Entries in terminfo source files consist of a number of
#      comma-separated fields. White space after each comma is ignored. 
#
sub parse_terminfo  {
    #my ($lines) = @_;
    ($lines) = @_;      # it would be "my ($lines)" if it weren't for lexdebug()

    my @lines = split /\n/, $lines;
    our @process_fields;
    for (our $lineno=0; $lineno<@lines; $lineno++) {
        our %field = (lineno => $lineno);
        our @fields = ();
        our $is_continuation;
        $lines[$lineno] =~ m{
              ^ \# .*           # ignore comment lines
            | ^ \h* $           # ignore blank lines
            | ^( \h* )
                                    (?{ $is_continuation = length $^N    })
                (?:
                    (?! \h )
                    ((?:[\\%^][^\n]|[^,\\%^\n=\#])+)
                                    (?{ local $field{capability} = $^N   })
                    (?:     = ((?:[\\%^][^\n]|[^,\\%^\n])*)
                                    (?{ local $field{assign} = $^N    })
                         | \# (\d+)
                                    (?{ local $field{num} = $^N    })
                         )?
                    , \h*  
                                    (?{ push(@fields, {%field})   })
                )+ $
        }x
            or die "syntax error on line " . ($lineno+1) . "\n";
            #or do {
            #    print "syntax error on line " . ($lineno+1) . "\n";
            #    print xxd($lines[$lineno]), "\n";
            #    exit;
            #};
        if (defined($is_continuation)) {
            if ($is_continuation) {
                push(@process_fields, @fields);
            } else {
                process_fields(@process_fields) if (@process_fields);
                @process_fields = (@fields);
            }
        }
    }
    process_fields(@process_fields) if (@process_fields);
}


sub process_fields {
    #print "--process--  ", Dumper \@_;
    
    print "\n\n================[ ", " ]================\n";
    foreach my $f (@_) {
        #print Dumper $f;
        printf "\t%-20s  ",  $f->{capability};
        printf "%s", qquote(terminfo_unescape($f->{assign}))     if $f->{assign};
        print "\n";
    }
}


BEGIN {
    our %escapes = (
        "\\E" => "\e",
    );
    #print Dumper \%escapes; exit;
sub terminfo_unescape {
    local $_ = shift;

    s#([\\^%].)#   $escapes{$1} || $1  #eg;
    return $_;
}
}


sub qquote {my$q=Data::Dumper::qquote($_[0]);$q=~s/^"//;$q=~s/"$//;$q}


# quickly read a whole file
sub slurp {my$p=open(my$f,"$_[0]")or die$!;my@o=<$f>;close$f;waitpid($p,0);wantarray?@o:join("",@o)}


# run a scalar through an external filter, and capture the results
# first arg is a list-ref that specifies the filter-command
use autodie;
sub filter_thru {my$pid=open my$fout,'-|'or do{my$pid=open my$fin,'|-',@{shift()};print$fin @_;close$fin;waitpid$pid,0;exit;};
                 my@o=<$fout>;close$fout;waitpid$pid,0;wantarray?@o:join'',@o}

sub xxd {filter_thru(['xxd'],@_)}

# display a string to the user, via 'less'
sub less {my$pid=open my$less,"|less";print$less @_;close$less;waitpid$pid,0}
