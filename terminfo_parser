#!/usr/bin/perl

# development testbed for creating a terminfo lexer/parser


# for the verification stage of this, you need to first run
# `tic` against the desired terminfo file, to populate your ~/.terminfo/ directory with the file under test



# TODO:
#       - this doesn't work on Perl 5.8...  figure out why it breaks...
#               - I suspect it's partly because 5.8 doesn't support 
#                 nested/re-entrant calls to the regexp engine

    use strict;
    use warnings;


    use Term::Terminfo;     # required for verification only

    use Data::Dumper;

    our $last_pos;
    our $lines;



    sub test_unescape {
        my $str = shift;
        print "\n";
        print xxd($str);
        print xxd(terminfo_unescape($str));
    }

if (0) {
    test_unescape("%'*'");
    test_unescape("^a");
    test_unescape("\\a");
    test_unescape("\\031");
    exit;
}


my $terminfo = slurp("terminfo.src");
#my $terminfo = slurp("termtypes.ti");
parse_terminfo($terminfo);

# terminfo(5) says of terminfo's syntax:
#
#      Entries  in  terminfo  consist  of  a  sequence of "," separated fields
#      (embedded commas may be escaped with a backslash or notated  as  \054).
#      White  space  after  the "," separator is ignored.  The first entry for
#      each terminal gives the names which are known for the  terminal,  sepa-
#      rated  by  "|"  characters.   The  first  name given is the most common
#      abbreviation for the terminal, the last name given  should  be  a  long
#      name  fully  identifying the terminal, and all others are understood as
#      synonyms for the terminal name.  All names but the last  should  be  in
#      lower  case and contain no blanks; the last name may well contain upper
#      case and blanks for readability.
#
#      A  number  of  escape  sequences   are  provided  in  the  string valued
#      capabilities for easy encoding of characters there.  Both \E and \e map
#      to  an  ESCAPE character, ^x maps to a control-x for any appropriate x,
#      and the sequences \n \l \r \t \b  \f  \s  give  a  newline,  line-feed,
#      return, tab, backspace, form-feed, and space.  Other escapes include \^
#      for ^, \\ for \, \, for comma, \: for :, and \0  for  null.   (\0  will
#      produce  \200,  which does not terminate a string but behaves as a null
#      character on most terminals, providing CS7 is specified.  See stty(1).)
#      Finally, characters may be given as three octal digits after a \.

#      ...
#
#      Sometimes  individual  capabilities must be commented out.  To do this,
#      put a period before the capability name.  For example, see  the  second
#      ind in the example above.

#      ...
#
#      Numeric  capabilities are followed by the character "#" and then a
#      positive value.

#      ...
#
#      String valued capabilities, such as el (clear to end of line sequence)
#      are given by the two-character code, an "=", and then a string ending
#      at the next following ",".
#       
#      ...
#
#      The % encodings have the following meanings:
#               (read terminfo(5) for full info about % encodings)
#
# The Single UNIX Specification further says:
#
#      Each description consists of a header (beginning in column 1) and one
#      or more lines that list the features for that particular device. Every
#      line in a terminfo source file must end in a comma. Every line in a
#      terminfo source file except the header must be indented with one or
#      more white spaces (either spaces or tabs).
#
#      Entries in terminfo source files consist of a number of
#      comma-separated fields. White space after each comma is ignored. 
#
sub parse_terminfo  {
    #my ($lines) = @_;
    ($lines) = @_;      # it would be "my ($lines)" if it weren't for lexdebug()

    my @lines = split /\n/, $lines;
    our @process_fields;
    for (our $lineno=0; $lineno<@lines; $lineno++) {
        our %field = (lineno => $lineno);
        our @fields = ();
        our $is_continuation;
        $lines[$lineno] =~ m{
              ^ \# .*           # ignore comment lines
            | ^ \h* $           # ignore blank lines
            | ^( \h* )
                                    (?{ $is_continuation = length $^N    })
                (?:
                    (?! \h )
                    ((?:  \\\d\d\d  |  [\\^][^\n]  |  [^,\\^\n=\#]  )+)
                       #  ^^^^^^^^     ^^^^^^^^     ^^^^^^^^^^^    various escape codes
                                    (?{ local $field{capability} = $^N   })
                    (?:     = ((?:  \\\d\d\d  |  [\\^][^\n]  |  [^,\\^\n]  )*)
                              ## same as above, but with [=\#] removed, and + changed to *
                                    (?{ local $field{assign} = $^N    })
                         | \# (\d+)
                                    (?{ local $field{num} = $^N    })
                         )?
                    , \h*  
                                    (?{ push(@fields, {%field})   })
                )+ $
        }x
            or die "syntax error on line " . ($lineno+1) . "\n\t$lines[$lineno]\n";
            #or do {
            #    print "syntax error on line " . ($lineno+1) . "\n";
            #    print xxd($lines[$lineno]), "\n";
            #    exit;
            #};
        if (defined($is_continuation)) {
            if ($is_continuation) {
                push(@process_fields, @fields);
            } else {
                process_fields(@process_fields) if (@process_fields);
                @process_fields = (@fields);
            }
        }
    }
    process_fields(@process_fields) if (@process_fields);
}


BEGIN {
    my %hardcopies;

    sub process_fields {
        #print "--process--  ", Dumper \@_;

        my $terminal = shift @_;

        #my @termnames = grep {defined $_} $terminal->{capability} =~ /^((?:[\\%^][^\n|]|[^,\\%^\n|])+)(?:\|((?:[\\%^][^\n|]|[^,\\%^\n|])+))*$/;
        my @termnames = split /\|/, $terminal->{capability};

        my %caps = map {$_->{capability} => 1} @_;
        my @uses = map {$_->{assign}} grep {$_->{capability} eq 'use'} @_;
        #print Dumper \%caps; exit;
        #if (@uses) {print Dumper \@uses; exit}

        if ($caps{hc}) {
            $hardcopies{$termnames[0]}++;
        } else {
            foreach my $use (@uses) {
                if ($hardcopies{$use}) {
                    $hardcopies{$termnames[0]}++;
                    last;
                }
            }
        }

        my $terminfo;
        if (!$caps{gn} && !$hardcopies{$termnames[0]} && $termnames[0] !~ /^(?:tvi912-2p|bg300-rv)$/) {
            $terminfo = Term::Terminfo->new($termnames[0]);
        }

        print "\n\n================[ ", join(" --- ", @termnames), " ]================\n";
        foreach my $f (@_) {
            #print Dumper $f;
            printf "\t%-20s  ",  $f->{capability};
            if ($f->{assign}) {
                my $unescape = terminfo_unescape($f->{assign});
                printf "%s", qquote($unescape);

                my $cap = $f->{capability};
                #if ($terminfo && $cap !~ /^use$|^\.|\@$/ && $cap !~ /[A-Z]/) {
                if ($terminfo && $cap !~ /^(?:use|E3|grbom|gsbom)$|^\.|\@$/) {
                    $cap =~ s/^OT//;        # see "obsolete" in the terminfo.src
                    my $actual = $terminfo->getstr($cap) || '';

                    if ($actual && $actual ne $unescape) {
                        print "\t\tERROR\n\t", " "x22, qquote($actual);
                    }
                }
            }
            print "\n";
        }
    }
}

BEGIN {
    our %escapes = (

        "\\a"  => "\x07",   # bell
        "\\b"  => "\x08",   # backspace
        "\\f"  => "\x0c",   # form feed
        "\\e"  => "\e",     # escape
        "\\l"  => "\x0a",   # line feed
        "\\n"  => "\x0a",   # newline
        "\\r"  => "\x0d",   # return
        "\\s"  => " ",      # space
        "\\t"  => "\t",     # horizontal tab
        "\\0"  => "\200",   # null   (see detailed info about this in terminfo(5)...   it's not clear to me why we use \200 instead of \x00)

        "^\\"  => "\x1c",
        "^]"   => "\x1d",
        "^^"   => "\x1e",
        "^_"   => "\x1f",

        # plain escapes
        "\\,"  => ",",
        "\\:"  => ":",
        "\\\\" => "\\",
        "\\^"  => "^",
    );
    for ('a'..'z') {
        $escapes{"^$_"} = chr(ord($_) - 96);
    }
    #print Dumper \%escapes; exit;
sub terminfo_unescape {
    local $_ = shift;

    s/
        \\(\d\d\d)    |
        (\%)(?=\\)    |         # i have no clue what the fuck this is...  but this is required to match the official parser's behavior
        ([\\^].)      |
        \%{(\d\d+)}   |
        \%'([^']+)'   |
        (%'[^']+'|%.)
    /
            defined($1) ? chr(oct($1))
          : defined($2) ? $2
          : defined($3) ? ($escapes{lc $3} || substr($3, -1))
          : defined($4) ? unescape_percent_char($4)
          : defined($5) ? ("%'" . terminfo_unescape($5) . "'")
          : defined($6) ? $6 : "YOUBROKEIT"
        /gex;
    return $_;
}
}


    sub unescape_percent_char {
        my $charnum = shift;
        if ($charnum >= 32 && $charnum <= 126 && $charnum != 92) {
            return "\%'" . chr($charnum) . "'";
        } else {
            return "\%{$charnum}";
        }
    }
    

sub qquote {my$q=Data::Dumper::qquote($_[0]);$q=~s/^"(.*)"$/$1/s;$q}
sub _quote {my$q=Data::Dumper::_quote($_[0]);$q=~s/^'(.*)'$/$1/s;$q}


# quickly read a whole file
sub slurp {my$p=open(my$f,"$_[0]")or die$!;my@o=<$f>;close$f;waitpid($p,0);wantarray?@o:join("",@o)}


# run a scalar through an external filter, and capture the results
# first arg is a list-ref that specifies the filter-command
use autodie;
sub filter_thru {my$pid=open my$fout,'-|'or do{my$pid=open my$fin,'|-',@{shift()};print$fin @_;close$fin;waitpid$pid,0;exit;};
                 my@o=<$fout>;close$fout;waitpid$pid,0;wantarray?@o:join'',@o}

sub xxd {filter_thru(['xxd'],@_)}

# display a string to the user, via 'less'
sub less {my$pid=open my$less,"|less";print$less @_;close$less;waitpid$pid,0}
