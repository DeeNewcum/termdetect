#!/usr/bin/perl

# development testbed for creating a terminfo lexer/parser


# for the verification stage of this, you need to first run
# `tic` against the desired terminfo file, to populate your ~/.terminfo/ directory with the file under test



# TODO:
#       - this doesn't work on Perl 5.8...  figure out why it breaks...
#               - I suspect it's partly because 5.8 doesn't support 
#                 nested/re-entrant calls to the regexp engine

    use strict;
    use warnings;

    use constant VALIDATE => 1;     # set to true to validate our results with the official parser

    use Data::Dumper;

    our $last_pos;
    our $lines;



    sub test_unescape {
        my $str = shift;
        print "\n";
        print xxd($str);
        print xxd(terminfo_unescape($str));
    }

if (0) {
    test_unescape("%'*'");
    test_unescape("^a");
    test_unescape("\\a");
    test_unescape("\\031");
    exit;
}


my $terminfo = "terminfo.src";          # http://invisible-island.net/ncurses/ncurses.faq.html#which_terminfo
#my $terminfo = "termtypes.ti";          # http://www.catb.org/~esr/terminfo/

my $terminfo_contents = slurp($terminfo);
my $parsed = parse_terminfo($terminfo_contents);
#print Dumper $parsed; exit;
validate__prepare_TERMINFO($terminfo)       if VALIDATE;
validate_terminfo($parsed)      if VALIDATE;


# terminfo(5) says of terminfo's syntax:
#
#      Entries  in  terminfo  consist  of  a  sequence of "," separated fields
#      (embedded commas may be escaped with a backslash or notated  as  \054).
#      White  space  after  the "," separator is ignored.  The first entry for
#      each terminal gives the names which are known for the  terminal,  sepa-
#      rated  by  "|"  characters.   The  first  name given is the most common
#      abbreviation for the terminal, the last name given  should  be  a  long
#      name  fully  identifying the terminal, and all others are understood as
#      synonyms for the terminal name.  All names but the last  should  be  in
#      lower  case and contain no blanks; the last name may well contain upper
#      case and blanks for readability.
#
#      A  number  of  escape  sequences   are  provided  in  the  string valued
#      capabilities for easy encoding of characters there.  Both \E and \e map
#      to  an  ESCAPE character, ^x maps to a control-x for any appropriate x,
#      and the sequences \n \l \r \t \b  \f  \s  give  a  newline,  line-feed,
#      return, tab, backspace, form-feed, and space.  Other escapes include \^
#      for ^, \\ for \, \, for comma, \: for :, and \0  for  null.   (\0  will
#      produce  \200,  which does not terminate a string but behaves as a null
#      character on most terminals, providing CS7 is specified.  See stty(1).)
#      Finally, characters may be given as three octal digits after a \.

#      ...
#
#      Sometimes  individual  capabilities must be commented out.  To do this,
#      put a period before the capability name.  For example, see  the  second
#      ind in the example above.

#      ...
#
#      Numeric  capabilities are followed by the character "#" and then a
#      positive value.

#      ...
#
#      String valued capabilities, such as el (clear to end of line sequence)
#      are given by the two-character code, an "=", and then a string ending
#      at the next following ",".
#       
#      ...
#
#      The % encodings have the following meanings:
#               (read terminfo(5) for full info about % encodings)
#
# The Single UNIX Specification further says:
#
#      Each description consists of a header (beginning in column 1) and one
#      or more lines that list the features for that particular device. Every
#      line in a terminfo source file must end in a comma. Every line in a
#      terminfo source file except the header must be indented with one or
#      more white spaces (either spaces or tabs).
#
#      Entries in terminfo source files consist of a number of
#      comma-separated fields. White space after each comma is ignored. 
#
sub parse_terminfo  {
    #my ($lines) = @_;
    ($lines) = @_;      # it would be "my ($lines)" if it weren't for lexdebug()

    my @parsed;

    my @lines = split /\n/, $lines;
    our @process_fields;
    for (our $lineno=0; $lineno<@lines; $lineno++) {
        our %field = (lineno => $lineno);
        our @fields = ();
        our $is_continuation;
        $lines[$lineno] =~ m{
              ^ \# .*           # ignore comment lines
            | ^ \h* $           # ignore blank lines
            | ^( \h* )
                                    (?{ $is_continuation = length $^N    })
                (?:
                    (?! \h )
                    ((?:  \\\d\d\d  |  [\\^][^\n]  |  [^,\\^\n=\#]  )+)
                       #  ^^^^^^^^     ^^^^^^^^     ^^^^^^^^^^^    various escape codes
                                    (?{ local $field{capability} = $^N   })
                    (?:     = ((?:  \\\d\d\d  |  [\\^][^\n]  |  [^,\\^\n]  )*)
                              ## same as above, but with [=\#] removed, and + changed to *
                                    (?{ local $field{assign} = $^N    })
                         | \# (\d+)
                                    (?{ local $field{num} = $^N    })
                         )?
                    , \h*  
                                    (?{ push(@fields, {%field})   })
                )+ $
        }x
            or die "syntax error on line " . ($lineno+1) . "\n\t$lines[$lineno]\n";
            #or do {
            #    print "syntax error on line " . ($lineno+1) . "\n";
            #    print xxd($lines[$lineno]), "\n";
            #    exit;
            #};
        if (defined($is_continuation)) {
            if ($is_continuation) {
                push(@process_fields, @fields);
            } else {
                push(@parsed, process_fields(@process_fields)) if (@process_fields);
                @process_fields = (@fields);
            }
        }
    }
    push(@parsed, process_fields(@process_fields)) if (@process_fields);

    return \@parsed;
}


sub process_fields {
    my @fields = @_;

    my $termfield = shift @fields;

    my @termnames = split /\|/, $termfield->{capability};
    my $descr = pop @termnames      if (@termnames >= 2);
    my %parsed = (
        termnames      => \@termnames,
        term_descr     => $descr,
        lineno_range   => [         # range of line numbers that this entry occupies
                $termfield->{lineno},       # first line
                $fields[-1]{lineno},        # last line
            ],
        );

    $parsed{fields} = [
            map {
                $_->{assign} = terminfo_unescape($_->{assign})      if $_->{assign};
                $_
            } @fields
        ];

    return \%parsed;
}


BEGIN {
    our %escapes = (

        "\\a"  => "\x07",   # bell
        "\\b"  => "\x08",   # backspace
        "\\f"  => "\x0c",   # form feed
        "\\e"  => "\e",     # escape
        "\\l"  => "\x0a",   # line feed
        "\\n"  => "\x0a",   # newline
        "\\r"  => "\x0d",   # return
        "\\s"  => " ",      # space
        "\\t"  => "\t",     # horizontal tab
        "\\0"  => "\200",   # null   (see detailed info about this in terminfo(5)...   it's not clear to me why we use \200 instead of \x00)

        "^\\"  => "\x1c",
        "^]"   => "\x1d",
        "^^"   => "\x1e",
        "^_"   => "\x1f",

        # plain escapes
        "\\,"  => ",",
        "\\:"  => ":",
        "\\\\" => "\\",
        "\\^"  => "^",
    );
    for ('a'..'z') {
        $escapes{"^$_"} = chr(ord($_) - 96);
    }
    #print Dumper \%escapes; exit;


# The output of this should EXACTLY match tigetstr(3).
# That is -- the percent parameters haven't been expanded (it doesn't do what tparm() does), but
# all other escape-codes should be expanded.
sub terminfo_unescape {
    local $_ = shift;

    s/
        \\(\d\d\d)    |
        (\%)(?=\\)    |         # i have no clue what the fuck this is...  but this is required to match the official parser's behavior
        ([\\^].)      |
        \%{(\d\d+)}   |
        \%'([^']+)'   |
        (%'[^']+'|%.)
    /
            defined($1) ? chr(oct($1))
          : defined($2) ? $2
          : defined($3) ? ($escapes{lc $3} || substr($3, -1))
          : defined($4) ? unescape_percent_char($4)
          : defined($5) ? ("%'" . terminfo_unescape($5) . "'")
          : defined($6) ? $6 : "YOUBROKEIT"
        /gex;
    return $_;
}
}

    sub unescape_percent_char {
        my $charnum = shift;
        if ($charnum >= 32 && $charnum <= 126 && $charnum != 92) {
            return "\%'" . chr($charnum) . "'";
        } else {
            return "\%{$charnum}";
        }
    }
    

# point $ENV{TERMINFO} to the right place
#       (and compile the terminfo file if necessary)
sub validate__prepare_TERMINFO {
    my ($terminfo_filename) = @_;

    my $terminfo_dir = "$ENV{HOME}/.terminfo.$terminfo_filename/";
    if (!-d $terminfo_dir) {
        system "tic", "-o$terminfo_dir", $terminfo_filename;
        $? == -1    and die "unable to run 'tic'\n";
    }

    $ENV{TERMINFO} = $terminfo_dir;
}



# a unit test to confirm our parser matches tic(1)'s parser
sub validate_terminfo {
    my ($parsed) = @_;

    eval 'use Term::Terminfo';
    $@ and die "the unit test requires Term::Terminfo to be installed\n\t";

    ## gather up all aliases
    my %canonical_name;     # mapping from   canonical_name => entry_structure
    my %all_term_names;     # mapping from   alias => canonical_name
    foreach my $entry (@$parsed) {
        my $canonical = $entry->{termnames}[0];

        $canonical_name{$canonical} = $entry;
        foreach my $termname (@{$entry->{termnames}}) {
            $all_term_names{$termname} = $canonical;
        }
    }

    ## gather up all "use" entries
    my %all_uses;
    my %first_level_uses;
    foreach my $entry (@$parsed) {
        my $canonical = $entry->{termnames}[0];
        foreach my $field (@{$entry->{fields}}) {
            if ($field->{capability} eq 'use') {
                push @{$first_level_uses{$canonical}}, $field->{assign};
            }
        }
    }
    # recursively explore the tree, find all nested "use"s
    foreach my $entry (@$parsed) {
        my $canonical = $entry->{termnames}[0];
        my %seen;
        my @all_uses;
        my @queue = @{$first_level_uses{$canonical} || []};
        while (@queue) {
            my $use = pop @queue;
            $use = $all_term_names{$use};       # get the canonical name
            next if $seen{$use}++;
            # according to terminfo(5):
            #           "If there are multiple use capabilities, they are merged in reverse order.
            #           That is, the rightmost use reference is processed first, then the one to its
            #           left, and so forth."
            push(@all_uses, $use);
            # depth-first search, so that the items in @all_uses remain in proper order
            #           (earlier = higher precedent)
            push(@queue, @{$first_level_uses{$use} || []});
        }
        # in @all_uses, entry [0] has the highest precedent, and the last entry has the lowest
        $all_uses{$canonical} = [@all_uses];
    }
    #print Dumper \%first_level_uses;  exit;
    print Dumper \%all_uses;    exit;


    ################################################################
    ##################### STOPPING POINT ###########################
    ################################################################
            # ^^^ The above code mostly works.
            #       Now, we need to split it off into a flatten_terminfo()
            #       routine, because it's something that's generally useful...  it isn't something
            #       that's specific to unit testing.
            #
            #       (after that, then come back here and continue...  the reason we need
            #        flatten_terminfo() functionality is because we need to know the ultimate
            #        value of the 'hc' capability for every terminal)
            #
            #       Also, we need to add tests to test ALL capabilities (ie. including the ones we
            #       inherit from "use" entries), not just the first-level capabilities.
            #       This will ensure that we test that our flatten_terminfo() code uses the same
            #       precedence rules that tic(1) uses.



    our %hardcopies;

    foreach my $entry (@$parsed) {
        my @termnames = @{$entry->[0]};
        my @fields = @{$entry}[1..scalar(@$entry)-1];

#        my %caps = map {$_->{capability} => 1} @fields;
#        my @uses = map {$_->{assign}} grep {$_->{capability} eq 'use'} @fields;
#        #print Dumper \%caps; exit;
#        #if (@uses) {print Dumper \@uses; exit}
#
#        if ($caps{hc}) {
#            $hardcopies{$termnames[0]}++;
#        } else {
#            foreach my $use (@uses) {
#                if ($hardcopies{$use}) {
#                    $hardcopies{$termnames[0]}++;
#                    last;
#                }
#            }
#        }
#
#        my $terminfo;
#        if (!$caps{gn} && !$hardcopies{$termnames[0]} && $termnames[0] !~ /^(?:tvi912-2p|bg300-rv)$/) {
#            $terminfo = Term::Terminfo->new($termnames[0]);
#        }

        print "\n\n================[ ", join(" --- ", @termnames), " ]================\n";
        foreach my $field (@fields) {
            printf "\t%-20s  ",  $field->{capability};
            if ($field->{assign}) {
                printf "%s", qquote($field->{assign});

#                my $cap = $field->{capability};
#                #if ($terminfo && $cap !~ /^use$|^\.|\@$/ && $cap !~ /[A-Z]/) {
#                if ($terminfo && $cap !~ /^(?:use|E3|grbom|gsbom)$|^\.|\@$/) {
#                    $cap =~ s/^OT//;        # see "obsolete" in the terminfo.src
#                    my $actual = $terminfo->getstr($cap) || '';
#
#                    if ($actual && $actual ne $field->{assign}) {
#                        print "\t\tERROR\n\t", " "x22, qquote($actual);
#                    }
#                }
            } elsif ($field->{num}) {
                printf "%s", $field->{num};
            }
            print "\n";
        }
    }
}


sub qquote {my$q=Data::Dumper::qquote($_[0]);$q=~s/^"(.*)"$/$1/s;$q}
sub _quote {my$q=Data::Dumper::_quote($_[0]);$q=~s/^'(.*)'$/$1/s;$q}


# quickly read a whole file
sub slurp {my$p=open(my$f,"$_[0]")or die$!;my@o=<$f>;close$f;waitpid($p,0);wantarray?@o:join("",@o)}


# run a scalar through an external filter, and capture the results
# first arg is a list-ref that specifies the filter-command
use autodie;
sub filter_thru {my$pid=open my$fout,'-|'or do{my$pid=open my$fin,'|-',@{shift()};print$fin @_;close$fin;waitpid$pid,0;exit;};
                 my@o=<$fout>;close$fout;waitpid$pid,0;wantarray?@o:join'',@o}

sub xxd {filter_thru(['xxd'],@_)}

# display a string to the user, via 'less'
sub less {my$pid=open my$less,"|less";print$less @_;close$less;waitpid$pid,0}
