#!/usr/bin/perl

# development testbed for creating a terminfo lexer/parser


# for the verification stage of this, you need to first run
# `tic` against the desired terminfo file, to populate your ~/.terminfo/ directory with the file under test



# TODO:
#       - this doesn't work on Perl 5.8...  figure out why it breaks...
#               - I suspect it's partly because 5.8 doesn't support 
#                 nested/re-entrant calls to the regexp engine

    use strict;
    use warnings;

    use constant UNIT_TEST => 1;     # set to true to validate our results against the official parser

    use Data::Dumper;



    sub test_unescape {
        my $str = shift;
        print "\n";
        print xxd($str);
        print xxd(terminfo_unescape($str));
    }

if (0) {
    test_unescape("%'*'");
    test_unescape("^a");
    test_unescape("\\a");
    test_unescape("\\031");
    exit;
}



my $terminfo = "terminfo.src";          # http://invisible-island.net/ncurses/ncurses.faq.html#which_terminfo
#my $terminfo = "termtypes.ti";          # http://www.catb.org/~esr/terminfo/

my $terminfo_contents = slurp($terminfo);
my $parsed = parse_terminfo($terminfo_contents);
$parsed = flatten_terminfo($parsed);
if (UNIT_TEST) {
    unittest__prepare_TERMINFO($terminfo);
    unittest_terminfo($parsed);
}


# terminfo(5) says of terminfo's syntax:
#
#      Entries  in  terminfo  consist  of  a  sequence of "," separated fields
#      (embedded commas may be escaped with a backslash or notated  as  \054).
#      White  space  after  the "," separator is ignored.  The first entry for
#      each terminal gives the names which are known for the  terminal,  sepa-
#      rated  by  "|"  characters.   The  first  name given is the most common
#      abbreviation for the terminal, the last name given  should  be  a  long
#      name  fully  identifying the terminal, and all others are understood as
#      synonyms for the terminal name.  All names but the last  should  be  in
#      lower  case and contain no blanks; the last name may well contain upper
#      case and blanks for readability.
#
#      A  number  of  escape  sequences   are  provided  in  the  string valued
#      capabilities for easy encoding of characters there.  Both \E and \e map
#      to  an  ESCAPE character, ^x maps to a control-x for any appropriate x,
#      and the sequences \n \l \r \t \b  \f  \s  give  a  newline,  line-feed,
#      return, tab, backspace, form-feed, and space.  Other escapes include \^
#      for ^, \\ for \, \, for comma, \: for :, and \0  for  null.   (\0  will
#      produce  \200,  which does not terminate a string but behaves as a null
#      character on most terminals, providing CS7 is specified.  See stty(1).)
#      Finally, characters may be given as three octal digits after a \.

#      ...
#
#      Sometimes  individual  capabilities must be commented out.  To do this,
#      put a period before the capability name.  For example, see  the  second
#      ind in the example above.

#      ...
#
#      Numeric  capabilities are followed by the character "#" and then a
#      positive value.

#      ...
#
#      String valued capabilities, such as el (clear to end of line sequence)
#      are given by the two-character code, an "=", and then a string ending
#      at the next following ",".
#       
#      ...
#
#      The % encodings have the following meanings:
#               (read terminfo(5) for full info about % encodings)
#
# The Single UNIX Specification further says:
#
#      Each description consists of a header (beginning in column 1) and one
#      or more lines that list the features for that particular device. Every
#      line in a terminfo source file must end in a comma. Every line in a
#      terminfo source file except the header must be indented with one or
#      more white spaces (either spaces or tabs).
#
#      Entries in terminfo source files consist of a number of
#      comma-separated fields. White space after each comma is ignored. 
#
sub parse_terminfo  {
    my ($lines) = @_;

    my @parsed;

    my @lines = split /\n/, $lines;
    our @process_fields;
    for (our $lineno=0; $lineno<@lines; $lineno++) {
        our %field = (lineno => $lineno);
        our @fields = ();
        our $is_continuation;
        $lines[$lineno] =~ m{
              ^ \# .*           # ignore comment lines
            | ^ \h* $           # ignore blank lines
            | ^( \h* )
                                    (?{ $is_continuation = length $^N    })
                (?:
                    (?! \h )
                    ((?:  \\\d\d\d  |  [\\^][^\n]  |  [^,\\^\n=\#]  )+)
                       #  ^^^^^^^^     ^^^^^^^^     ^^^^^^^^^^^    various escape codes
                                    (?{ local $field{capability} = $^N   })
                    (?:     = ((?:  \\\d\d\d  |  [\\^][^\n]  |  [^,\\^\n]  )*)
                              ## same as above, but with [=\#] removed, and + changed to *
                                    (?{ local $field{assign} = $^N    })
                         | \# (\d+)
                                    (?{ local $field{num} = $^N    })
                         )?
                    , \h*  
                                    (?{ push(@fields, {%field})   })
                )+ $
        }x
            or die "syntax error on line " . ($lineno+1) . "\n\t$lines[$lineno]\n";

        if (defined($is_continuation)) {
            if ($is_continuation) {
                push(@process_fields, @fields);
            } else {
                push(@parsed, process_fields(@process_fields)) if (@process_fields);
                @process_fields = (@fields);
            }
        }
    }
    push(@parsed, process_fields(@process_fields)) if (@process_fields);

    return \@parsed;
}


sub process_fields {
    my @fields = @_;

    my $termfield = shift @fields;

    my @termnames = split /\|/, $termfield->{capability};
    my $descr = pop @termnames      if (@termnames >= 2);
    my %parsed = (
        termnames      => \@termnames,
        term_descr     => $descr,
        lineno_range   => [         # range of line numbers that this entry occupies
                $termfield->{lineno},       # first line
                $fields[-1]{lineno},        # last line
            ],
        );

    $parsed{fields} = [
            map {
                $_->{assign} = terminfo_unescape($_->{assign})      if $_->{assign};
                $_
            } @fields
        ];

    return \%parsed;
}


BEGIN {
    our %escapes = (

        "\\a"  => "\x07",   # bell
        "\\b"  => "\x08",   # backspace
        "\\f"  => "\x0c",   # form feed
        "\\e"  => "\e",     # escape
        "\\l"  => "\x0a",   # line feed
        "\\n"  => "\x0a",   # newline
        "\\r"  => "\x0d",   # return
        "\\s"  => " ",      # space
        "\\t"  => "\t",     # horizontal tab
        "\\0"  => "\200",   # null   (see detailed info about this in terminfo(5)...   it's not clear to me why we use \200 instead of \x00)

        "^\\"  => "\x1c",
        "^]"   => "\x1d",
        "^^"   => "\x1e",
        "^_"   => "\x1f",

        # plain escapes
        "\\,"  => ",",
        "\\:"  => ":",
        "\\\\" => "\\",
        "\\^"  => "^",
    );
    for ('a'..'z') {
        $escapes{"^$_"} = chr(ord($_) - 96);
    }
    #print Dumper \%escapes; exit;


# The output of this should EXACTLY match tigetstr(3).
# That is -- the percent parameters haven't been expanded (it doesn't do what tparm() does), but
# all other escape-codes should be expanded.
sub terminfo_unescape {
    local $_ = shift;

    s/
        \\(\d\d\d)    |
        (\%)(?=\\)    |         # i have no clue what the fuck this is...  but this is required to match the official parser's behavior
        ([\\^].)      |
        \%{(\d\d+)}   |
        \%'([^']+)'   |
        (%'[^']+'|%.)
    /
            defined($1) ? chr(oct($1))
          : defined($2) ? $2
          : defined($3) ? ($escapes{lc $3} || substr($3, -1))
          : defined($4) ? unescape_percent_char($4)
          : defined($5) ? ("%'" . terminfo_unescape($5) . "'")
          : defined($6) ? $6 : "YOUBROKEIT"
        /gex;
    return $_;
}
}

    sub unescape_percent_char {
        my $charnum = shift;
        if ($charnum >= 32 && $charnum <= 126 && $charnum != 92) {
            return "\%'" . chr($charnum) . "'";
        } else {
            return "\%{$charnum}";
        }
    }


# The terminfo specification allows for use= clauses (and @ items to cancel things inside uses).
# This takes the parsed fields that contain use= clauses, and flattens everything out so you don't
# have to do a lot of work to find out what the final values for a given $TERM are.
sub flatten_terminfo {
    my ($parsed) = @_;

    eval 'use Term::Terminfo';
    $@ and die "the unit test requires Term::Terminfo to be installed\n\t";

    ## gather up all aliases
    my %canonical_name;     # mapping from   canonical_name => entry_structure
    my %all_term_names;     # mapping from   alias => canonical_name
    foreach my $entry (@$parsed) {
        my $canonical = $entry->{termnames}[0];

        $canonical_name{$canonical} = $entry;
        foreach my $termname (@{$entry->{termnames}}) {
            $all_term_names{$termname} = $canonical;
        }
    }

    ## gather up all "use" entries
    my %all_uses;
    my %first_level_uses;
    foreach my $entry (@$parsed) {
        my $canonical = $entry->{termnames}[0];
        foreach my $field (@{$entry->{fields}}) {
            if ($field->{capability} eq 'use') {
                push @{$first_level_uses{$canonical}}, $field->{assign};
            }
        }
    }
    ## recursively explore the tree, find all nested "use"s
    foreach my $entry (@$parsed) {
        my $canonical = $entry->{termnames}[0];
        my %seen;
        my @all_uses;
        my @queue = @{$first_level_uses{$canonical} || []};
        while (@queue) {
            my $use = pop @queue;
            $use = $all_term_names{$use};       # get the canonical name
            next if $seen{$use}++;
            # according to terminfo(5):
            #           "If there are multiple use capabilities, they are merged in reverse order.
            #           That is, the rightmost use reference is processed first, then the one to its
            #           left, and so forth."
            push(@all_uses, $use);
            # depth-first search, so that the items in @all_uses remain in proper order
            #           (earlier = higher precedent)
            push(@queue, @{$first_level_uses{$use} || []});
        }
        # in @all_uses, entry [0] has the highest precedent, and the last entry has the lowest
        $all_uses{$canonical} = [@all_uses];
    }
    #print Dumper \%first_level_uses;  exit;
    #print Dumper \%all_uses;    exit;

    ## now, combine all the capabilities, in the precedence order that's specified in %all_uses
    my %flattened;
    foreach my $canonical (keys %canonical_name) {
        my %flattened_fields;
        my @precedence = reverse($canonical, @{$all_uses{$canonical}});
        foreach my $layer (@precedence) {
            foreach my $field (@{$canonical_name{$layer}{fields}}) {
                my $cap = $field->{capability};
                if ($cap eq 'use') {
                    next;       # we already handled the hierarchy, above
                } elsif ($cap =~ s/\@$//) {
                    delete $flattened_fields{$cap};
                } else {
                    $flattened_fields{$cap} = $field;
                }
            }
        }
        $flattened{$canonical} = {
            %{$canonical_name{$canonical}},
            fields => \%flattened_fields,
        }
    }
    #dump_terminal(values %flattened);  exit;

    ## add aliases
    while (my ($alias, $canonical) = each %all_term_names) {
        if (!exists $flattened{$alias}) {
            $flattened{$alias} = {
                alias => $canonical,
                termnames => [$alias],      # $flattened{$canonical}{termnames},
            };
        }
    }
    #dump_terminal(values %flattened);  exit;

    return \%flattened;
}





    

# point $ENV{TERMINFO} to the right place
#       (and compile the terminfo file if necessary)
sub unittest__prepare_TERMINFO {
    my ($terminfo_filename) = @_;

    my $terminfo_dir = "$ENV{HOME}/.terminfo.$terminfo_filename/";
    if (!-d $terminfo_dir) {
        system "tic", "-o$terminfo_dir", $terminfo_filename;
        $? == -1    and die "unable to run 'tic'\n";
    }

    $ENV{TERMINFO} = $terminfo_dir;
}


# a unit test to confirm our parser matches tic(1)'s parser
sub unittest_terminfo {
    my ($parsed) = @_;

    if (ref($parsed) eq 'HASH') {
        $parsed = [ values %$parsed ];
    }

    foreach my $entry (@$parsed) {
        next if ($entry->{alias});
        next if ($entry->{fields}{hc});     # Term::Terminfo doesn't like hardcopy entries
        next if ($entry->{fields}{gn});     # Term::Terminfo doesn't like generic entries


        print "================[ ", join(" -- ", @{$entry->{termnames}}, $entry->{term_descr} || ''),
                    " ]================\n";

        my $terminfo = Term::Terminfo->new($entry->{termnames}[0]);
        my $fields = [ sort { dump_sort_fields() } values %{$entry->{fields}} ];
        #while (my ($cap, $field) = each %{$entry->{fields}}) {
        foreach my $field (@$fields) {
            my $cap = $field->{capability};

            #dump_field($field);
                printf "%20s", $field->{capability};
                if ($field->{assign}) {
                    print " = ", qquote($field->{assign});
                } elsif ($field->{num}) {
                    print " # ", qquote($field->{num});
                }

            $cap =~ s/^OT//;        # see "obsolete" in the terminfo.src
            my $actual = $terminfo->getstr($cap) || '';
            if ($actual && $actual ne $field->{assign}) {
                print "\t\tERROR\n";
                printf "%-20s   %s\n", "", qquote($actual);
            }
            print "\n";
        }

        print "\n";
    }
}


sub dump_terminal {
    my @terms = sort {$a->{termnames}[0] cmp $b->{termnames}[0]} @_;
    foreach my $terminal (@terms) {
        print "================[ ", join(" -- ", @{$terminal->{termnames}}, $terminal->{term_descr} || ''),
                    " ]================\n";
        if ($terminal->{alias}) {
            #printf "%20s   %s\n\n", "alias of", $terminal->{alias};
            next;
        }

        my $fields = $terminal->{fields};
        if (ref($fields) eq 'HASH') {
            $fields = [ sort { dump_sort_fields() } values %$fields ];
        }
        dump_field(@$fields);
        print "\n";
    }
}


sub dump_field {
    foreach my $field (@_) {
        printf "%20s", $field->{capability};
        if ($field->{assign}) {
            print " = ", qquote($field->{assign}), "\n";
        } elsif ($field->{num}) {
            print " # ", qquote($field->{num}), "\n";
        } else {
            print "\n";
        }
    }
}


sub dump_sort_fields {
                        field_type($a) cmp field_type($b) ||
                        $a->{capability} cmp $b->{capability}
}


sub field_type {
    my ($field) = @_;
    return "3assign" if ($field->{assign});
    return "2num" if ($field->{num});
    return "1bool";
}


sub qquote {my$q=Data::Dumper::qquote($_[0]);$q=~s/^"(.*)"$/$1/s;$q}
sub _quote {my$q=Data::Dumper::_quote($_[0]);$q=~s/^'(.*)'$/$1/s;$q}


# quickly read a whole file
sub slurp {my$p=open(my$f,"$_[0]")or die$!;my@o=<$f>;close$f;waitpid($p,0);wantarray?@o:join("",@o)}


# run a scalar through an external filter, and capture the results
# first arg is a list-ref that specifies the filter-command
use autodie;
sub filter_thru {my$pid=open my$fout,'-|'or do{my$pid=open my$fin,'|-',@{shift()};print$fin @_;close$fin;waitpid$pid,0;exit;};
                 my@o=<$fout>;close$fout;waitpid$pid,0;wantarray?@o:join'',@o}

sub xxd {filter_thru(['xxd'],@_)}

# display a string to the user, via 'less'
sub less {my$pid=open my$less,"|less";print$less @_;close$less;waitpid$pid,0}
