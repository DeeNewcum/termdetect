#!/usr/bin/perl

# There are several ANSI escape codes that can be used between the server and client for
# query/reply.  This utility shows how your current terminal responds to a particular query.

    use strict;
    use warnings;

    use Time::HiRes qw[alarm];
    #use Term::ReadKey;

    use Data::Dumper;

    use constant DEBUG => 0;

    # from Regexp::Common::ANSIescape
    #       ^^ problem?  this doesn't allow things like "\e7" -- the manual for GNU Screen says that should save the cursor and attributes
    #use constant ansi_regexp => "(?:(?:\e\\[|\233)(?:[0-?]*)(?:[ -/]*[\@-~])|\e[\@-OQ-WYZ\\\\]|[\200-\217\221-\227\231\232\234]|(?:\e[]PX^_]|[\235\220\230\236\237])(?:.|\n)*?(?:\e\\\\|\234))";
    #use constant ansi_regexp_capture => "((?:\e\\[|\233)([0-?]*)([ -/]*[\@-~])|\e[\@-OQ-WYZ\\\\]|[\200-\217\221-\227\231\232\234]|(?:\e[]PX^_]|[\235\220\230\236\237])(.|\n)*?(?:\e\\\\|\234))";

    #print Dumper [parse_sequence("this is a test\e[1;2Rthis is another test\e[1;2Ryeeha")];  exit;



## cooked mode, echo off
#Term::ReadKey::ReadMode(2);
system 'stty', '-icanon', '-echo', 'eol', "\001";
$|++;

END {
    ## reset tty mode before exiting
    #Term::ReadKey::ReadMode(0);         
    system 'stty', 'icanon', 'echo', 'eol', chr(0);
}

if (!is_cursor_position_supported()) {
    die "Terminal is unable to report the cursor position.  This is required for many tests.\n";
}


run_and_display_test("\e[5n");      # DSR - device status report
run_and_display_test("\e[x");       # terminal parameters
run_and_display_test("\e[c");       # DA - device attributes
run_and_display_test("\5");         # ENQ - enquiry character


exit;







# We use the cursor-position report a lot...   if that doesn't work, then things will get hung up
# and take way too long.
# Figure this out before we waste a lot of time.
sub is_cursor_position_supported {
    output("\e[6n");
    my $reply = get_ansi_reply(1.0, 'R');
    #print perl_string_encode($reply), "\n";
    return 0 unless defined($reply);
    my %reply = %{ parse_one_sequence($reply) };
    #print Dumper \@reply; exit;
    return ($reply{mnemonic} eq 'CPR-reply');
}


sub run_and_display_test {
    my ($sequence) = @_;

    my $response = run_test(@_);

    printf  "%-20s   %-20s\n",
            ansi_escape($sequence),
            ansi_escape($response);
}


sub run_test {
    my ($sequence) = @_;

    output("\e[6n", $sequence, "\e[6n");      # send a CPR (cursor position report) before and after
    #debug_show_remaining_input();

    my @replies;
    my $replies = '';
    while (1) {
        my $reply = get_ansi_reply(0.0, qr/[R\e]/);
        #print ansi_escape($reply), "\n"; sleep 5;exit;



        #push(@replies, parse_sequence($reply));


        $replies .= $reply;
        @replies = parse_sequence($replies);

        last if (scalar(grep {is_CPR($_)} @replies) >= 2);

    }
    
    my @cprs = grep {is_CPR($_)} @replies;
    # we dropped down a line...   what do we do here??
    die "don't know how to handle this" if ($cprs[0]{params}[0] != $cprs[-1]{params}[0]);
    my $chars_moved = $cprs[-1]{params}[1] - $cprs[0]{params}[1];
    if ($chars_moved > 0) {
        return "[+$chars_moved]";
    } elsif (@replies == 2) {
        # no response
        return "";
    } else {
        my $response = $replies[1];
        if (ref($response)) {
            return $response->{full};
        } else {
            return $response;
        }
    }
    #print ansi_escape(Dumper \@replies); exit;
}

        sub is_CPR {
            local $_ = shift;
            return 0 unless ref($_) eq 'HASH';
            return ($_->{mnemonic} && $_->{mnemonic} eq 'CPR-reply');
        }



# parse an ANSI reply  (or even a request)
#
# Actually, it will parse SEVERAL sequences if need be.
# It returns a list:
#       - non-ANSI sequences are returned as a string
#       - ANSI sequences are returned as a hash-ref
sub parse_sequence {
    my ($sequence) = @_;

    #print Dumper ['parse_sequence -- ', $sequence];

    return unless defined($sequence);

    my @parsed;

    #my @seqs = split /((@{[ansi_regexp()]}))/, $sequence;
    my @seqs = grep {length($_)} split /(\e[^a-zA-Z]*[a-zA-Z])/, $sequence;
    #print 'parse_sequence -- ', Dumper \@seqs; #exit;
    #return;
    foreach my $seq (@seqs) {
        next unless ($seq =~ /\S/);
        if ($seq =~ /^\e/) {
            push(@parsed, parse_one_sequence($seq));
        } else {
            push(@parsed, $seq);
        }
    }

    return @parsed;
}


sub parse_one_sequence {
    my ($sequence) = @_;

    #print Dumper ['parse_one_sequence -- ', ansi_escape($sequence)];

    use constant sequences => { map {my @F = split ' ', $_, 3; $F[0] => [$F[1], $F[2]]} split /\n/, <<"EOF" };
            \e[...R       CPR-reply       Cursor Position Report - Reply
EOF

    my %parsed;
    my $mnemonic;       # the mnemonic listed in ECMA-48
    my $mnemonic_long;  # the full name, listed in ECMA-48
    if ($sequence =~ /^(\e[^\da-z]*)(\d*(?:;\d*)*)([^\d;]+)$/s) {
        my %parsed;
        my $prefix = $1;
        my $suffix = $3;
        $parsed{full} = $sequence;
        $parsed{params} = [ split /;/, $2 ];

        my $prefix_suffix = "$prefix...$suffix";
        if (exists(&sequences->{$prefix_suffix})) {
            $mnemonic      = &sequences->{$prefix_suffix}[0];
            $mnemonic_long = &sequences->{$prefix_suffix}[1];
        }

        if ($mnemonic) {
            $parsed{mnemonic} = $mnemonic;
            $parsed{name}     = $mnemonic_long;
        } else {
            $parsed{UNRECOGNIZED} = $prefix_suffix;
        }
        return \%parsed;
    } else {
        #die "don't know what to do with:\n\t" . ansi_escape($sequence) . "\n\t";
        return $sequence;
    }
}


sub get_ansi_reply {
    my ($timeout,                           # seconds to wait for a reply;  use 0 for no alarm
        $response_end_character) = @_;      # if we see this character, we know the response is finished

    $timeout = 1.0 unless defined($timeout);

    my $reply = '';
    eval {
        local $SIG{ALRM} = sub { die "alarm\n" };
        alarm($timeout)     if ($timeout != 0);

        if (defined($response_end_character) && $response_end_character eq '') {
            # an empty-string means "read everything that's in the buffer"...  this assumes that
            # the response will be sent all-at-once, and that there will be a slight timegap in between
            # the response and anything the human types
            my $numchars = sysread(STDIN, $reply, 1024);
            $reply = substr($reply, 0, $numchars);
        } else {
            while (1) {
                if (defined(my $c = getc())) {
                    #print ".";
                    $reply .= $c;
                    if (defined($response_end_character)) {
                        if (ref($response_end_character) eq 'Regexp') {
                            last if ($c =~ $response_end_character);
                        } else {
                            last if ($c eq $response_end_character);
                        }
                    }
                }
            }
        }
    };
    if ($@) {
        return undef if ($@ eq "alarm\n");
        die $@;
    }
    print "got reply: ", ansi_escape($reply), "\n"      if (DEBUG);
    return $reply;
}


sub output {
    my $str = join("", @_);
    print "  sending: ", ansi_escape($str), "\n"        if (DEBUG);
    print $str;
    $|++;
}



sub debug_show_remaining_input {
    print "---- debug_show_remaining_input ----\n";
    while (my $reply = get_ansi_reply(0.0, '')) {
        print ansi_escape($reply), "\n";
    }
    exit;
}




# turn things like "\e" and "\033" into their single-character equivalents, using standard perl string-literal rules
sub perl_string_decode {
    my $encoded = shift;
    my $decoded = eval "qq\000$encoded\000";
}


# turn things like chr(27) into '\e' -- into a visible presentation
sub perl_string_encode {
    my $decoded = shift;
    my $encoded = Data::Dumper::qquote($decoded);
    $encoded =~ s/^"(.*)"$/$1/s;
    return $encoded;
}

sub ansi_escape { map {(my $a = $_);
        $a =~ s/\e/\\e/g;
        $a =~ s/\x5/\\5/g;
        $a} @_ }


# display a string to the user, via `xxd`
sub xxd {open my$xxd,"|xxd"or die$!;print$xxd $_[0];close$xxd}
